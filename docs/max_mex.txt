
                                        10. Introduction to MEX Programming


             10.1. About MEX

             The Maximus Extension Language (MEX) is an advanced program-
             ming language designed to interface with the Maximus bulletin
             board system. MEX is a true programming language that pro-
             vides support for many advanced language features, including
             functions, dynamic strings and arrays.

             MEX can be used to add user-defined features and extend the
             functionality of a standard Maximus system. For example, MEX
             can be used to implement a full-screen chat program, a call-
             back verifier, or to implement a user-specific database using
             standard file I/O function calls.

             MEX was designed to overcome limitations in MECCA, which was
             the original Maximus extension language. MECCA was primarily
             intended to handle simplistic screen formatting and graphics,
             but it could also handle very simple forms of flow control
             and menus.

             Although MECCA is still supported, MEX is the extension lan-
             guage of choice for many advanced tasks. As an example of
             MEX's power, parts of the standard Maximus distribution have
             been rewritten in MEX, including the file and message area
             headers, the Change Menu, and more.

             MEX can interface to internal Maximus routines to obtain in-
             formation about the current user, to display screen output,
             or to perform repetition and flow control. In fact, MEX pro-
             grams can accomplish almost anything that can be done in a
             general-purpose programming language such as C or Pascal.

             However, all of this power does not mean that MEX is hard to
             use. The MEX language incorporates the best features from the
             C, BASIC and Pascal languages, including time-saving features
             such as dynamic strings, pass-by-reference parameters, and
             structures.


             10.2. MEX Road Map

             The rest of this section introduces a simple MEX program, de-
             scribes how to compile MEX programs, and describes how to run
             MEX programs from Maximus.

             To find more information about MEX:



             10. Introduction to MEX Programming                       162

             *  For general information on MEX programming and language
                features, please see section 11.

             *  For information on the MEX run-time library, please see
                section 15.

             *  For reference information on the MEX language itself, in-
                cluding the language grammar, please see section 16.


             10.3. Creating a Sample MEX Program

             Like MECCA, MEX is a compiled language. This means that the
             description of what the program does, otherwise known as the
             source file, must be processed by the MEX compiler before the
             program can be run. Source files always have an extension of
             .mex.

             The source for a MEX program is simply an ASCII text file. An
             external editor, such as the DOS edit.com or the OS/2 e.exe,
             is used to create and edit a MEX source file.

             The best way to start programming in MEX is to write a sample
             program. To do this, start up a text editor (such as one of
             the two programs mentioned above). Then enter the following
             lines, using punctuation and spaces exactly as shown below:

                #include <max.mh>

                // This is a hello world program.

                int main()
                {
                  print("Hello, world\n");
                  return 0;
                }

             After the text has been entered, double-check each line to
             ensure that it appears just like given above.

             When run, this program will simply print "Hello, world" and
             return to Maximus. However, before trying to compile and run
             this program, it will help to become familiar with the basic
             elements of the MEX language:

                #include <max.mh>

             This line, "#include <max.mh>", must be present in all MEX
             programs. This line instructs the MEX compiler to read in a
             .mh file (a MEX header) that tells it how to interface with
             Maximus.



             10. Introduction to MEX Programming                       163

             Without the max.mh file, MEX would not know how to display
             output to the user, how to access information in the user re-
             cord, or how to perform many other operations.

             Unless otherwise noted, max.mh is the only header file that
             needs to be included in most MEX programs.

                // This is a hello world program.

             This line is a comment. A comment begins with two forward
             slashes, and everything on the same line, following the
             slashes, is ignored by the compiler.

             The MEX compiler completely ignores comments, so it is quite
             possible to write a "commentless" program. However, comments
             serve to remind the reader about how a program works, and
             they can also act as an aid to other people who try to modify
             an existing MEX program.

             In general, it is a good idea to place comments throughout a
             MEX program, especially in areas where the program logic is
             not self-evident.

                int main()
                {
                  (inner portion of source omitted)
                }

             The structure shown above is known as a function. Functions
             are the building blocks which are used to create MEX pro-
             grams. All of the actions that a MEX program performs are
             contained within functions. Only a brief description of func-
             tions will be given here, but a detailed discussion of func-
             tions can be found in section 11.

             The first line of the function, "int main()", tells the MEX
             compiler to create a function called "main". All MEX programs
             must have a main function. When a MEX program receives con-
             trol from Maximus, the program will always start running at
             the main function.

             The braces, "{" and "}", serve as bounds for the main func-
             tion. Everything that is part of the main function must be
             inside the braces.

                print("Hello, world\n");

             This statement is the "meat" of our simple program, since it
             instructs Maximus to perform a specific action. This line is
             a function call, which consists of a function name, followed
             by a pair of parentheses which contain the function argu-
             ments.



             10. Introduction to MEX Programming                       164

             In this case, the function name is print. The print function
             is used to send output to the screen.

             The function arguments are "Hello, world\n". The print func-
             tion will take the provided arguments and display them on the
             screen. (The "\n" is a newline escape sequence, as will be
             explained later in more detail.)

             In short, while the function name tells Maximus what to do,
             the function arguments tell Maximus how to do it.

             Several other things are noteworthy about this function call:

             *  The line ends with a semicolon. In MEX, all statements must
                end with a semicolon. In most places, the MEX compiler ig-
                nores whitespace (such as spaces, tabs, and ends of lines),
                so it uses the semicolon to mark the end of a statement.

             *  Notice that the function argument, "Hello, world\n", is en-
                closed in double quotes. In MEX, this is known as a string.
                Strings consist of zero or more letters, numbers, or punc-
                tuation marks that are surrounded by a pair of double
                quotes. Strings are used for storing, manipulating, and
                displaying words and other types of textual information.

             *  In the example above, the print function was only called
                with one argument. Some functions only accept a fixed num-
                ber of arguments, but in the case of print, it can accept
                as many arguments as desired.

                To pass more than one argument to a function, simply add a
                comma-delimited list of arguments within the parentheses.
                For example, to print the words "Alex", "Betty" and
                "Chuck", the following line could be used:

                  print("Alex ", "Betty ", "Chuck ");

                In addition, some functions do not accept any arguments.
                Even in these cases, the parentheses must still be present,
                since they denote that a function call should be made. For
                example, given a function called foo that accepted no argu-
                ments, it could be called like this:

                  foo();

             *  In the function argument, the last two characters, "\n,"
                are known as an escape sequence. When the MEX compiler sees
                a backslash followed by the letter n, it recognizes this as
                the newline escape sequence. This escape sequence then gets
                translated to a linefeed, which causes the cursor to skip
                down to the next line after the string is displayed.



             10. Introduction to MEX Programming                       165

                In short, every time MEX sees a "\n" enclosed in double
                quotes, the "\n" causes the cursor to be sent to the begin-
                ning of the next line.

                For example, if our sample program contained the following
                line:

                  print("This is a\ntest of the\n\noutput text.\n");

                then the output would look like this:

                  This is a
                  test of the

                  output text.

                While other escape sequences are also supported, only the
                newline escape sequence is important for now.

             We finish our analysis of the sample program by examining the
             last line in the main function:

                return 0;

             This line is a return statement. This statement indicates to
             Maximus that the MEX program completed successfully. This
             normally appears as the last line in the main function. (The
             return statement has other uses which will be discussed
             later; but for simple, single-function programs, only one re-
             turn statement is necessary.)

             This completes our analysis of the sample MEX program. See
             the following sections for information on compiling and exe-
             cuting MEX programs under Maximus.


             10.4. Compiling MEX Programs

             The main purpose of the MEX compiler, mex.exe, is to read in
             a source .mex file and compile it into a .vm file. This .vm
             file can be read and executed by Maximus. The compilation
             converts the MEX source file into a form that can be executed
             while a user is on-line.

             The secondary purpose of the MEX compiler is to check the
             program source for errors. If the compiler detects an error
             while compiling your source, it will print an error message
             and abort the compilation. A text editor must then be used to
             edit the source file and correct the error.

             Assuming that you called your file test.mex, simply type the
             following to compile the program:



             10. Introduction to MEX Programming                       166

                mex test.mex

             The compiler will then process the source file. If the source
             file is incorrect, the compiler will display error messages
             and abort the compilation. If this happens, ensure that the
             source file matches the example given in the section above.
             (The line numbers given in the warning messages can be used
             to determine the approximate location of the error.)


             10.5. Running MEX Programs

             Once a MEX program has been compiled, it can be executed by
             Maximus.

             There are three primary ways to invoke a MEX program from
             Maximus: from a menu option, from a .bbs or .mec file, or
             from a File or Uses statement in max.ctl:


             10.5.1. Running MEX Programs from Menu Options

             The easiest way to add a new MEX program to the system is to
             give it its own menu option. To add a menu option, a line
             similar to the following can be added to one of the menu
             definitions in menus.ctl.

             For example, the following line can be added to the defini-
             tion for "Menu Main" to run the MEX program that was created
             in the previous section:

                MEX     m\test                  Normal   "Test"

             This line instructs Maximus to execute a program called
             m\test. Maximus will assume that the file is relative to the
             main Maximus directory, so if you installed Maximus in
             c:\max, it will expect to find the file in the c:\max\m di-
             rectory.

             After making changes to menus.ctl, the Maximus control files
             should also be recompiled with SILT.

             Maximus reads in the compiled source file (as generated by
             the MEX compiler), so it will actually be looking for a file
             called c:\max\m\test.vm. If the file is not found, an appro-
             priate error message will be displayed (and also placed in
             the system log).

             If everything went well, upon pressing the "T" key at the
             main menu, the output of the "Hello world" program should ap-
             pear on the screen.



             10. Introduction to MEX Programming                       167

             For more information on the format of menu options, please
             see section 18.8.


             10.5.2. Running MEX Programs from .MEC Files

             If desired, MEX programs can also be run directly from .mec
             or .bbs files. The [mex] MECCA token tells Maximus to run a
             MEX program:

             For example, these lines could be added to welcome.mec:

                [mex]m\test
                [pause]

             After recompiling the welcome.mec file with MECCA, the
             c:\max\m\test.vm program will be run every time a user logs
             on, in addition to displaying the rest of the normal welcome
             screen.


             10.5.3. Running MEX Programs from MAX.CTL

             In many of the Maximus control files, numerous keywords allow
             .bbs filenames to be specified. Maximus allows a MEX program
             to be substituted for a .bbs file in any of these places.

             To indicate to Maximus that it is to run a MEX program in-
             stead of a .bbs file, simply add a colon (":") to the begin-
             ning of the filename. For example, to completely replace the
             \max\misc\logo.bbs file with a MEX program, the Uses Logo
             statement in max.ctl can be modified to read as follows:

                Uses Logo   :M\Test

             In this line were used, instead of displaying the standard
             \max\misc\logo.bbs file, Maximus would instead run the
             \max\m\test.vm program.

             This technique can also be applied to any other part of the
             system that requests a .bbs filename. For example, even
             though the MEX menu option can be used to run MEX programs
             directly, we can also use the Display_File menu option to
             display a MEX program, even though it is normally used to
             display .bbs files:

                Display_File   :M\Test               Normal   "Test"








                                                  11. MEX Language Tutorial

             This section is an introduction to programming in MEX. No
             prior programming experience is assumed, although familiarity
             with other programming languages will help in some areas.
             While this section tries to teach some basic programming
             principles, it is not a substitute for a general text on pro-
             gramming methodology.

             Before reading this section, new programmers should first
             read and try out the "Hello world" program from the introduc-
             tion..

             Those who are already familiar with C or Pascal should read
             section 12. That section provides a brief overview of the
             differences between MEX and each of the other two languages.
             However, material in this section will also be helpful in
             demonstrating basic language principles.


             11.1. Program Development Cycle

             Like many things, designing a MEX program is an iterative
             task. Seldom do developers write a program correctly on the
             first attempt; this section is an introduction to the devel-
             opment cycle of a typical computer program.

             The first step in designing a computer program is to deter-
             mine the end goal of the program. What must the program do?
             What are its inputs? What are its outputs?

             These three questions must be answered before any further
             steps can be taken in program design. Without a clear idea of
             what a program is supposed to accomplish, proceeding to the
             design and implementation stages all but guarantees a poorly-
             designed program in the long run.

             After the program's inputs and outputs have been determined,
             the next step is to decompose the program's operations into
             functional units. This process is described in more detail in
             section 11.2.1 (below), but in essence, it involves breaking
             a large problem into many smaller subproblems.

             The next step is the implementation stage. Here, you must en-
             ter the program source code (or a portion thereof) into the
             computer. The program source code now takes the form of an
             ASCII source file with a .mex extension.



             11. MEX Language Tutorial                                 170

             Now, the MEX compiler is invoked to compile the program
             source. If any compilation errors occur, you must go back to
             the previous step and re-edit the program.

             Additionally, a compile-time error might alert you to a prob-
             lem with the program design. In this case, you must return to
             the design stage and modify the program specification.

             Next, the compiled MEX program is run from within Maximus.
             Even if the program compiles correctly, there still may be
             numerous functional errors in the program. If problems are
             observed, you must return to a previous stage, either to re-
             edit the program source, or to re-design the portion of the
             program that is causing the problem.

             In theory, if a program is designed correctly the first time,
             very few design changes will be required in the later devel-
             opment stages. However, as a program grows in size, it be-
             comes much more difficult to design the program in sufficient
             detail to ensure that all of the program components will in-
             teroperate correctly without any design revision.

             In addition, other factors may necessitate a design change,
             such users requesting additional features to be added to your
             program.

             This entire development cycle is often referred to as the
             "waterfall effect." Problems noted in the implementation
             stage may require a return to the design stage; problems in
             the compilation stage may require a return to the implementa-
             tion or design stage; problems in the execution stage may re-
             quire a return to any of the preceding stages.

             In addition, the impact of "feature requests" should not be
             underestimated. A common sentiment among programmers is that
             no one else except themselves will use a program, so why
             bother to design it or comment it properly? Unfortunately,
             these types of programs all too often end up being distrib-
             uted and used by others, so it usually pays to design and im-
             plement a program correctly the first time.

             For programs with a large base of installed users, the pro-
             gram development cycle never stops. Small changes are always
             being made to the program design; small tweaks are always be-
             ing made to the program source code; and minor problems are
             always being found during program execution.

             Familiarizing yourself with the program development cycle is
             the best way to ensure success when developing a program, no
             matter how large or how small.



             11. MEX Language Tutorial                                 171

             11.2. Elements of a MEX Program

             A standard MEX program consists of two main components: a set
             of instructions that tell the computer what to do, and the
             information on which those instructions operate.

             The set of instructions is often referred to as code, while
             the information on which it operates is often referred to as
             data.


             11.2.1. About Code

             In MEX, the program code is implemented using functions. Al-
             though the sample program in the introduction had only one
             function, main, most MEX programs have a number of intercon-
             nected functions. Functions are building blocks that are used
             to design programs in a modular manner.

             For example, given a MEX program that retrieves a user's date
             of birth, the program could be broken up into a number of
             functions:

             *  One function could display a prompt and ask the user to en-
                ter a line of text.

             *  Another function could validate the text entered to ensure
                that it is a valid date.

             *  A third function could store the date information in the
                user record.

             *  A fourth and final function, the main function, could tie
                all of the above functions together by invoking them in the
                right order.

             Within each function are a number of statements. These state-
             ments are the step-by-step instructions that tell the com-
             puter what to do. For example, the statements in the "date
             validation function" could do something similar to the fol-
             lowing:

             *  Separate the date into year, month and day components

             *  Check if the year is greater than 1890. If not, reject the
                date.

             *  Check if the month number is greater than 0 and less than
                13. If not, reject the date

             *  Check if the day number is within the bounds for the indi-
                cated month. (1 to 31, 1 to 30, 1 to 28, and so on)



             11. MEX Language Tutorial                                 172

             By breaking down the major components of a program into func-
             tions, and then by breaking down each function into a se-
             quence of statements, programs can be written to solve com-
             plex everyday problems.


             11.2.2. About Data

             Program data consists of constants and variables. Like the
             name implies, constants never change. Given an expression
             such as "2 + 2", the number "2" is a constant.

             Variables, on the other hand, can change while your program
             is being run. Variables must be given names, as in conven-
             tional mathematics. For example, given an expression such as
             "i + 2," the symbol i is a variable. Depending on the value
             of i, the expression itself can have different values. For
             example, if i has a value of 6, the value of the expression
             "i + 2" is 8.

             In MEX, a variable also has a type. The type of a variable
             indicates the kind of information that the variable is al-
             lowed to hold. Table 11.1 lists some of the basic data types
             supported by MEX:

             Table 11.1 MEX Data Types

              Type    Description

              char    Variables of this type can hold a single charac-
                      ter, including letters, numbers, digits, punctua-
                      tion, and control characters. Variables of the
                      this type can also be used to store very small
                      numbers in the range of 0 to 255. Examples of
                      characters are `a,' `6,' and `:'. Characters are
                      described in more detail in a later section.

              int     An int can hold numbers in the range -32768 to
                      32767. This is an "integer" data type, meaning
                      that it can only hold whole numbers, both positive
                      and negative. This means that numbers that contain
                      a fractional component, such as 8.6 and -4.3, are
                      not allowed.

              long    A long can hold numbers in the range -2147483648
                      to 2147483647. This is an "integer" data type,
                      meaning that it can only hold whole numbers, both
                      positive and negative. This means that numbers
                      that contain a fractional component, such as 8.6
                      and -4.3, are not allowed.

              string  This is a "dynamic string" data type. Strings are
                      commonly used for many word or text-oriented ap-



             11. MEX Language Tutorial                                 173

                      plications, such as printing output to the screen,
                      reading a sequence of keystrokes from the key-
                      board, or any other task which requires characters
                      to be "grouped."

                      Strings are dynamic in nature, meaning that they
                      grow and shrink along with their contents. Conse-
                      quently, no "maximum length" need be set when de-
                      claring a string.

                      Examples of dynamic strings are "Maximus" and
                      "Alexander the Great."

                      Strings are described in more detail in a later
                      section.

              struct  A structure is an aggregate, user-defined data
                      type that contains multiple objects of other
                      types. For example, a structure could hold an in-
                      teger, a character and a string. Structures will
                      be discussed in more detail in a later section.

              array   An array is an aggregate, user-defined data type
                      that contains multiple objects of the same data
                      type. For example, an array could contain 500 dis-
                      tinct integers.

              void    This is a special data type that is normally only
                      used for functions that do not return values. The
                      void data type cannot hold a value and cannot be
                      used in calculations. This type is discussed in
                      more detail in a later section.



             The three integral types described above, char, int and long,
             come in both signed and unsigned versions. A signed type can
             represent a negative number, whereas an unsigned type cannot.
             (However, an unsigned type can store numbers twice as large
             as a signed type.)

             The modifiers signed and unsigned can be inserted in front of
             one of the three integral type names to specify a signed or
             an unsigned type.

             The char type is unsigned by default, whereas int and long
             are both signed by default.

             For example, MEX supports the signed char type (with a range
             of -128 to 127), the unsigned int type (with a range of 0 to
             65536) and the unsigned long type (with a range of 0 to
             4294967296).



             11. MEX Language Tutorial                                 174




             11.3. Variable Declarations

             All MEX programs must declare variables before they can be
             used. The variable declaration tells the compiler two things:
             the name of the variable, and the type of information that
             the variable will be used to store.

             In a MEX program, variables can be declared in two different
             places:

             *  In a block at the top of the .mex source file. Variables
                declared here are known as global variables. Global vari-
                ables are accessible to all of the functions in a program,
                and these variables maintain their value throughout the
                execution of the entire program.

             *  In a block at the top of each function. Variables declared
                here are known as local variables. Local variables are only
                accessible within the function in which they are declared.
                These variables lose their values as soon as the containing
                function finishes executing.

             A variable block simply denotes an area of the source code
             that contains one or more variable declarations. There is no
             explicit keyword to tell the MEX compiler that it is process-
             ing a variable block or that variables are being declared;
             this is detected by context alone. Variables can be declared
             at the top of the source file, and just after the opening
             brace ("{") of functions.

             Note to advanced programmers: variables can also be placed at
             the beginning of any basic block in a function, and at other
             top-level points in the source file (outside of functions).
             However, this capability should only be used when absolutely
             necessary.

             A variable declaration block looks like this:

                int: i, j, k;

             The word int is the variable type. (In declarations, every-
             thing to the left of the colon (":") is treated as the vari-
             able type.)

             The comma-delimited list that follows the type, "i, j, k," is
             the list of variables to declare.

             The variable declaration ends with a semicolon (";"). This
             semicolon tells the compiler where the declaration ends.



             11. MEX Language Tutorial                                 175

             For the most part, variable names can be assigned arbitrar-
             ily. However, a few restrictions are imposed:

             *  The name must be from 1 to 32 characters long.

             *  The name is case-sensitive. This means that "delta,"
                "Delta," "DELTA," and "DeLtA" refer to four distinct ob-
                jects.

             *  Names can include letters and underscores. Names can also
                include digits, except in the first character of the name.
                (This means that "top10" is a valid name, whereas "7up" is
                not.)

             In the example above, three integers were created, with names
             i, j and k. Of course, variables of different types can also
             be declared within one block. The example below shows how to
             declare variables of different types within a declaration
             block:

                char: c;
                string: str;
                int: i;
                int: j;

             In the declaration above, a character c is created, in addi-
             tion to a string str and integers i and j. Notice that a
             semicolon follows each declaration.

             A comma-delimited list could have also been used to write an
             equivalent declaration block:

                char: c;
                string: str;
                int: i, j;

             As can be seen above, variables of the same type can be de-
             clared in a comma-delimited list, as well as in separate dec-
             larations, with no change in functionality.

             All integral variables are automatically initialized to 0
             when they are declared. All string variables are initialized
             to the null string ("").


             11.3.1. Character Variables

             Both the char and string data types are used for storing dis-
             playable information. However, characters and strings are
             used for quite distinct purposes.

             A char is normally used when only one letter, number, punc-
             tuation symbol or control character needs to be stored. In



             11. MEX Language Tutorial                                 176

             addition, a char can store any integer number that is in the
             range 0 to 255. Hence, chars are also useful for storing very
             small numbers.

             To assign a value to a variable of type char, simply enclose
             the letter, number or punctuation mark in single quotes. For
             example:

                char: c;

                c := 'q';        // c holds the letter q
                  or
                c := ':';        // c holds a colon

             This approach is adequate for assigning most types of charac-
             ter constants. However, some character values cannot be con-
             veniently entered in this approach. For example, how does one
             enter a newline character, or for that matter, how does one
             enter a character that contains a single quote?

             The answer lies in escape characters. Within character con-
             stants (and also within strings), the backslash is used as an
             escape character. Whenever the compiler recognizes an escape
             character in a character or string constant, it also reads
             the immediately-following character and treats the two as a
             pair.

             By using two-character escape sequences, you can easily place
             non-printable and special characters in the source file.
             Table 11.2 lists the escape characters supported by MEX:

             Table 11.2 MEX Escape Characters

              Escape    Name       ASCII  Description
              character            code

              \n        Newline    10     As seen in the sample MEX pro-
                                          gram in the introduction, this
                                          character sends the cursor down
                                          one line and moves it to the
                                          left-hand side of the screen.
              \r        Carriage   13     A carriage return moves the
                        return            cursor to the beginning of the
                                          current line.
              \a        BEL        7      The BEL character sends an
                                          audible beep to the user. (When
                                          displayed using print, this is
                                          normally not heard on the local
                                          console.)
              \b        Backspace  8      The backspace character moves
                                          the cursor back by one column.
              \f        Formfeed   12     The formfeed character clears
                                          the screen.



             11. MEX Language Tutorial                                 177

              \t        Tab        9      The tab character sends the
                                          cursor to the next horizontal
                                          tab stop.
              \'        Single     39     A single quote character (').
                        Quote
              \"        Double     34     A double quote character (").
                        Quote
              \\        Backslash  92     A backslash character (\).



             11.3.2. String Variables

             Strings are normally used when a large number of characters
             need to be manipulated as a single block, or when parts of a
             block of characters need to be manipulated independently.

             Strings can be assigned just like any other variables:

                string: s;

                s := "Julius Caesar";

             After this code is run, the variable s will contain "Julius
             Caesar." To modify the string at a later point in the pro-
             gram, only reassigning the string is necessary, as shown be-
             low:

                #include <max.mh>

                int main()
                {
                  string: s;

                  s := "Napoleon";

                  // ... perform conquests here ...

                  s := "King Henry IV";
                  return 0;
                }

             In the above program segment, the assignment of strings of
             varying length to s is automatically managed by the MEX run-
             time environment. No explicit "maximum length" need be speci-
             fied when declaring the variables, regardless of the size of
             the string.

             Strings can include any of the escape characters described in
             the previous section.

             In addition, MEX allows you to manipulate parts of strings as
             characters. The "[ ]" operator can be used to extract a char-



             11. MEX Language Tutorial                                 178

             acter from a specific point in a string, or to place a new
             character into a string. The expression:

                str [ idx ]

             instructs MEX to extract character number idx from the string
             and to convert it to a character, with an idx of 1 represent-
             ing the first character in the string.

             This notation can be used for both examining characters in
             strings and modifying the characters in an existing string.
             MEX will automatically expand the string and pad it with
             spaces if an expression attempts to add a character beyond
             the end of the string.

             For example:

                #include <max.mh>

                int main()
                {
                  string: s;
                  char: c;

                  s := "Philistine";
                  c := s[1];        // c is now 'P'
                  s[3] := c;        // s is now "PhPlistine"

                  // Now expand string by writing beyond end.

                  s[13] := 'o';     // s is now "PhPlistine  o"
                  print(s);
                  return 0;
                }

             11.4. Variable Scope

             A variable's scope is defined as the region of the source
             code which is capable of accessing or modifying that vari-
             able. The MEX rules for scoping are derived from the C lan-
             guage (which was in turn derived from Algol 68).

             In MEX, two simple scoping rules are applied:

             *  The scope of global variables begins at the point in the
                source file where they are declared. The scope of the vari-
                able extends to the end of the file. A variable which is
                declared as global can be used by any function in the en-
                tire program, and the variable's contents are preserved
                across function calls. Variables can be declared globally
                by simply placing the declaration at the top of the file,
                outside of any function body.



             11. MEX Language Tutorial                                 179

             *  The scope of a local variable begins at the opening brace
                ("{") of the block in which it is declared. The scope ex-
                tends over all nested blocks, and it terminates at the
                closing brace ("}") of the block in which it was declared.
                Variables declared inside a function are said to have a lo-
                cal scope, since they can only be accessed from within that
                function. Variables with a local scope are automatically
                allocated and deallocated when a function is called; hence,
                local variables do not have their values preserved across
                different calls of the same function.


             11.5. Preprocessor

             The MEX compiler includes a rudimentary preprocessor which is
             controlled by preprocessor directives. These directives in-
             struct it to perform compile-time substitutions and compari-
             sons of keywords in the source code.

             All preprocessor directives begin with a hash ("#") character
             at the beginning of the line.

             MEX supports the following preprocessor directives:

             #define name value

                The #define directive instructs the compiler to examine the
                source code and replace all instances of the word name with
                the value of value. For all intents and purposes, the com-
                piler behaves as if value had been entered in the source
                code rather than name. All such substitutions are performed
                before a source line is processed by the rest of the com-
                piler.

                For example, the following piece of code:

                #define ASSIGN_VARIABLE myint

                int: myint;

                ASSIGN_VARIABLE := 3;

                is equivalent to the following code in all respects:

                int: myint;

                myint := 3;

             #include <filename>

                The #include directive instructs the compiler to read in
                the header file filename and process it as if its contents
                were placed directly within the source file being compiled.



             11. MEX Language Tutorial                                 180

                This directive is useful for splitting up a large file into
                multiple parts.

                In the introduction, the #include directive was also used
                to include a file called max.mh, the standard system in-
                clude file. The max.mh file contains all of the definitions
                required to interface your program with Maximus. While
                these definitions could be copied into each and every MEX
                program, it is much more convenient to put these defini-
                tions all in one place and then #include the file from all
                MEX programs.

                The filename to be included must be placed within angle
                brackets, as shown in the example above. MEX will first
                look for the file in the current directory; if it cannot be
                found there, MEX will try to find the file in the same di-
                rectory as the .mex file that is currently being compiled.
                Finally, MEX will attempt to find the file in the directory
                specified by the MEX_INCLUDE environment variable.


             11.6. Calculations and Arithmetic

             MEX supports a wide variety of arithmetic and logical opera-
             tors which permit many different operations to be performed
             on the variables and data used by a program.

             After declaring a set of variables that can hold arbitrary
             values, the next thing a programmer may want to do is assign
             values to those variables.

             The simplest way to assign a value to a variable is to use
             the assignment operator. The assignment operator is entered
             as two separate characters: a colon followed immediately by
             an equals sign (":=").

             The assignment operator is similar to the "equals sign" in
             conventional mathematics; it assigns the value on the right-
             hand side of the assignment operator to the variable on the
             left-hand side.

             For example, after running the following program:

                #include <max.mh>

                int main()
                {
                  int: i;
                  char: c;
                  long: l;

                  i := 4;
                  c := 'q';



             11. MEX Language Tutorial                                 181

                  l := 12345678;

                  return 0;
                }

             the variable i will contain the number 4, c will contain the
             character 'q', and l will contain the number 12345678.

             One variable can also be assigned to another, as shown in the
             following program:

                #include <max.mh>

                int main()
                {
                  int: i, j;

                  i := 3;   // i now contains 3
                  j := i;   // j now contains 3 too

                  return 0;
                }

             In addition, many other operations can be performed on vari-
             ables. Many of the standard arithmetic operations, including
             addition, subtraction, multiplication and division, can also
             be performed on variables of types char, int and long. (Note
             that arithmetic operations cannot be performed on strings.
             However, the "+" symbol functions as a catenation operator to
             combine the contents of two strings.)

             MEX also supports a set of boolean logic operators, including
             "and" and "or." Lastly, MEX also supports bitwise logic op-
             erators, such as bitwise and and bitwise or.

             In general, an operator can be combined and used with other
             variables as follows:

                <expression-left> <operator> <expression-right>

             <operator> is one of the arithmetic operators from the table
             below. <expression-left> and <expression-right> can be arbi-
             trary expressions made up of other operators. For an example,
             given "3 + 5," the <expression-left> would be "3", the
             <operator> would be "+," and the <expression-right> would be
             "5."

             Table 11.3 lists the operators supported by MEX:



             11. MEX Language Tutorial                                 182

             Table 11.3 MEX Operators

              Operator  Description

              +         Addition and catenation. This operator yields the
                        arithmetic addition of two integer operands, such
                        as an int and an int, or a long and a long.

                        Also, when both <expression-left> and
                        <expression-right> are strings, the + operator
                        functions as a catenation operator to combine the
                        two strings.

              -         Subtraction. This operator yields the arithmetic
                        difference of the right-hand operand and the
                        left-hand operand.

              *         Multiplication. This operator yields the arithme-
                        tic multiplication of the left-hand operand with
                        the right-hand operand.

              /         Division. This operator yields the arithmetic di-
                        vision of the left-hand operand by the right-hand
                        operand.

              %         Modulo-division. This operator yields the remain-
                        der of the left-hand operand divided by the
                        right-hand operand.

              =         Equality. The result of an equality comparison is
                        1 if the two compared objects contain the same
                        value, or 0 if they do not.

              <>        Inequality. The result of an inequality compari-
                        son is 1 if the two compared objects do not con-
                        tain the same value, and 0 if they do.

              <=, <,    Logical comparators. These are the less-than-or-
              >=, >     equal, less-than, greater-than-or-equal and
                        greater-than operators. All of these operators
                        yield a result of 1 if the comparison between the
                        left-hand operand and the right-hand operand is
                        true; otherwise, they yield 0.

              and       Logical and. The logical and operator yields a
                        result of 1 if both of its operands are non-zero;
                        otherwise, it yields 0.

              or        Logical or. The logical or operator yields a re-
                        sult of 1 if either (or both) of its operands are
                        non-zero; otherwise, it yields 0.



             11. MEX Language Tutorial                                 183

              &         Bitwise and. This operator yields the bitwise and
                        of two integral operands. Each bit in the result
                        is a 1 only if the bits in the equivalent posi-
                        tions in both operands are both equal to 1.

              |         Bitwise or. This operator yields the bitwise or
                        of two integral operands. Each bit in the result
                        is a 1 if either of the bits in the equivalent
                        positions of the operands are equal to 1.
              shl       Shift-left. This operator shifts the left-hand
                        operand to the left by the number of bits speci-
                        fied by the right-hand operand. This operator im-
                        plements a logical shift and does not necessarily
                        preserve the sign of the operand, regardless of
                        whether it is signed or unsigned.
              shr       Shift-right. This operator shifts the left-hand
                        operand to the right by the number of bits speci-
                        fied by the right-hand operand. This operator im-
                        plements a logical shift; bits shifted in on the
                        left-hand side of the word are always 0.


             The normal mathematical order of evaluation applies to all
             calculations. (A table listing the exact operator precedence
             can be found in section 16.)

             When expressions involve operands which have different types,
             the operand with the smallest range is always promoted to the
             type of the other operand. If two operands are the same type
             but one is unsigned and the other is signed, the unsigned op-
             erand is always converted to a signed operand.

             This code demonstrates the simple arithmetic operators:

                #include <max.mh>

                int main()
                {
                  int: i, j, k;

                  i := 3;
                  j := 4 * i;         // j = 12
                  k := j / 3 + 1;     // k = 5

                  return 0;
                }

             In addition, parentheses can be used in any expression to ex-
             plicitly specify the order of evaluation:

                #include <max.mh>

                int main()



             11. MEX Language Tutorial                                 184

                {
                  int: i, j, k;

                  i := 3;
                  j := 4 * i;         // j = 12
                  k := j / (3 + 1);   // k = 3

                  return 0;
                }

             The logical operators are also quite useful for evaluating
             true/false expressions. Unlike other languages, MEX has no
             explicit "boolean" data type. Instead, any integral expres-
             sion can be evaluated as a boolean expression. Expressions
             which evaluate to zero are considered to be false, while all
             non-zero expressions are considered to be true. Boolean-like
             macro definitions for TRUE and FALSE can be found in max.mh.

             For example:

                #include <max.mh>

                int main()
                {
                  int: i, j, k, l, m;

                  i := 0;
                  j := 4;

                  k := i and k;       // k = 0
                  l := i or j;        // l = 1
                  m := l and k;       // m = 0

                  return 0;
                }

             Although MEX does not have an explicit not operator, it is
             easy to test if a boolean condition is false by simply com-
             paring it with 0:

                #include <max.mh>

                int main()
                {
                  int: i, j, k, l;

                  i := 2;
                  j := 3;
                  k := (i = 3);     // k = 0 since i <> 3
                  l := (k = 0)      // l = not k = 1

                  return 0;
                }



             11. MEX Language Tutorial                                 185


             Last but not least, the + operator can be used to catenate
             (combine) strings. For example:

                #include <max.mh>

                int main()
                {
                  string: s1, s2, s3;

                  s1 := "Foo";
                  s2 := "Bar";
                  s3 := s1 + s2;      // s3 = "FooBar"
                  print(s3);
                  return 0;
                }

             The string catenation operator can also be applied to multi-
             ple strings at a time:

                #include <max.mh>

                int main()
                {
                  string: s1, s2, s3, s4;

                  s1 := "string1";
                  s2 := "string2";
                  s3 := "string3";
                  s4 := s1 + s2 + s3;
                  print(s4);
                  return 0;
                }

             11.7. Displaying Output

             As seen in the sample program in the introduction, the print
             function is used to display output to the user. However,
             print is not limited to displaying just predefined text. The
             print function can also display the contents of variables and
             combine multiple data types into one statement.

             In general, multiple arguments can be used within a print
             statement by providing a comma-delimited list of variables or
             constants to be displayed. Providing such a list is equiva-
             lent to listing each variable in a sequence of separate print
             statements.

             In other words, given a declaration such as this:

                string: a, b, c;

                a := "Alpha ";



             11. MEX Language Tutorial                                 186

                b := "Bravo ";
                c := "Charlie ";

             the following code segment:

                print(a, b, c);

             will display "Alpha Bravo Charlie ". However, the following
             code segment will also produce the same output:

                print(a);
                print(b);
                print(c);

             However, print is not limited to displaying only strings.
             Both characters and integers can also be displayed:

                #include <max.mh>

                int main()
                {
                  char: c;
                  int: i;
                  string: s;

                  s := "The best solution to the problem is ";
                  c := '#';
                  i := 1;

                  print(s, c, i);
                  return 0;
                }

             This code will display:

                The best solution to the problem is #1

             One further point is that the print function does not add any
             extra spacing when displaying variables. Had an extra space
             not been included at the end of the string s, the output
             would have appeared as follows:

                The best solution to the problem is#1

             Similarly, the print function does not automatically move the
             cursor to the next line after displaying the specified vari-
             ables. If this cursor movement is desired, the newline escape
             sequence ('\n') should be inserted at the end of the print
             statement, as shown below:

                string: s;
                char: c;



             11. MEX Language Tutorial                                 187

                s := "Text #";
                c := '2';

                print(s, c, '\n');

             This code will display "Text #2" and move the cursor to the
             beginning of the next line.


             11.8. Flow Control

             In the preceding MEX examples, the programs have all executed
             the statements in the main function from top to bottom. How-
             ever, we may want to execute only some of the statements en-
             closed in a function, or in some cases, we may want to repeat
             some of its statements more than once.

             The flow of a program is the order in which the computer exe-
             cutes statements within a function. Adding flow control
             statements to a MEX program allows the designer to modify the
             flow and specify the conditions necessary for groups of
             statements to be executed or iterated (repeated).

             There are two types of flow control statements: conditional
             statements and iterative statements. Conditional statements
             allow a set of statements to be executed or skipped based on
             a specified condition, while iterative statements allow a
             group of statements to be executed multiple times.


             11.8.1. Conditional Execution

             The most basic form of conditional flow control is the if
             statement. The if statement allows the conditional selection
             of a group of statements.

             The if statement has two separate forms. The standard form
             looks like this:

                if (expr)
                  statement1

             If the expression inside the parentheses evaluates to non-
             zero, statement1 is executed. Otherwise, statement1 is
             skipped.

             The second form of the if statement looks like this:

                if (expr)
                  statement1
                else
                  statement2



             11. MEX Language Tutorial                                 188

             This is also referred to as the if / else statement. If expr
             evaluates to non-zero, only statement1 is executed. Other-
             wise, only statement2 is executed.

             Note that if itself is a statement, so multiple if / else
             statements can be chained together as shown below:

                if (a+b > c)
                  print("a+b > c");
                else if (b+c < a)
                  print("b+c < a");
                else if (d*e = 0)
                  print("d*e = 0");
                else
                  print("none of the above");

             In addition, the if statement can be used to conditionally
             execute multiple statements by using a compound statement. A
             compound statement is a pair of braces, between which can be
             any number of other statements. This means that constructs
             such as this can be used:

                if (a > c)
                {
                  print("a > c\n");
                  d := 0;
                }
                else
                {
                  print("a <= c\n");
                  d := 1;
                }

             In this example, if a is greater than c, MEX will display "a
             > c" and set d to 0. Otherwise, it will display "a <= 3" and
             set d to 1.

             The if statement can also be nested, as shown below:

                if (a > c)
                {
                  if (a > d)
                       print("a is bigger than c and d\n");
                  else
                       print("a is bigger than c only\n");
                }
                else
                  print("a is smaller than c\n");



             11. MEX Language Tutorial                                 189

             11.8.2. Iterative Flow Control

             Iteration is used when one or more statements need to be exe-
             cuted multiple times. Iteration is also known as looping or
             repetition.

             MEX supports three different types of iterative flow control:
             the while statement, the do .. while statement, and the for
             statement:


             11.8.2.1. while

             The simplest form of iteration is the while statement (or
             while loop). This statement instructs MEX to repeat the fol-
             lowing statement as long as a given expression is non-zero.

             A standard while statement looks like this:

                while (expr)
                  statement1;

             As with the if statement, statement1 can be either a single
             statement or a compound statement.

             Before every iteration of the loop, including before the
             first iteration, expr is evaluated. If expr evaluates to
             zero, the loop is skipped. Otherwise, statement1 is executed
             once, and then the whole process repeats. (This implies that
             if expr is initially zero, the loop will never be executed.)

             For example, the following code fragment causes the body of
             the while loop, the "i := i + 1" statement, to execute ten
             times:

                #include <max.mh>

                int main()
                {
                  int: i;

                  i := 1;

                  while (i <= 10)
                       i := i + 1;

                  return 0;
                }

             The "i := i + 1" could have easily been replaced with a com-
             pound statement, such as one which increments the counter and
             then calls print to display the value of the counter:



             11. MEX Language Tutorial                                 190

                #include <max.mh>

                int main()
                {
                  int: i;

                  i := 1;

                  while (i <= 10)
                  {
                       print("i = ", i, '\n');
                       i := i + 1;
                  }

                  return 0;
                }


             11.8.2.2. do .. while

             Conceptually, the do .. while statement (or do .. while loop)
             is very similar to the while statement. A do .. while state-
             ment looks like this:

                do
                  statement1
                while (expr);

             The only difference between a do .. while statement and a
             standard while statement is the point in time at which expr
             is evaluated. With a do .. while statement, the statement
             statement1 is executed first, and then expr is tested. This
             means that the loop will always be iterated at least once,
             regardless of the value of expr.

                #include <max.mh>

                int main()
                {
                  int: i;

                  i := 0;

                  do
                  {
                       print("i = ", i, '\n');
                       i := i + 1;
                  }
                  while (i > 0 and i <= 9);

                  return 0;
                }



             11. MEX Language Tutorial                                 191

             This code will increment i from 1 to 10, as in the previous
             example. However, the loop condition has been modified so
             that the loop will exit if "i > 0 and i <= 10" is false.

             On the first iteration, i is set to zero. However, the loop
             condition is not tested until the end of the loop, after i
             has been incremented to 1, so the loop condition is true.


             11.8.2.3. for

             The for statement (or the for loop) is also quite similar to
             the while statement, but the for statement allows the loop
             initialization and termination conditions to be written in a
             much more concise manner.

             A for statement looks like this:

                for (initexpr; testexpr; postexpr)
                  statement1;

             When processing a for loop,  the compiler will proceed as
             follows:

             1. Before anything else is done, initexpr is evaluated. Since
                this expression is evaluated only once, it is commonly used
                to initialize a variable used in the loop test. (Note that
                "expressions" such as this can include assignments and
                function calls.)

             2. Next, testexpr is evaluated. If this expression evaluates
                to zero, the loop is skipped.

             3. statement1 is executed. This statement is also known the
                body of the loop. Overall, statement1 is continually exe-
                cuted as long as testexpr evaluates to non-zero.

             4. postexpr is evaluated. This expression is normally used to
                increment some sort of loop counter.

             5. Branch back to step 2.

             A simple for statement looks like this:

                for (i := 1; i <= 10; i := i + 1)
                  print("i = ", i, '\n');

             This loop simply counts from one to ten, displaying the value
             of i while doing so. To break down the loop operation in de-
             tail:

             1. Before the loop begins, i is initialized to 1.



             11. MEX Language Tutorial                                 192

             2. Next, i is compared with ten. This test succeeds, so the
                print statement in the body of the loop is executed.

             3. i is then incremented by one.

             4. The whole process repeats by comparing i with ten, and then
                performing the actions from 2 through 4 again.

             From this, one can see that the for statement is just a
             shorthand notation for the while statement. An equivalent
             representation for the for statement is shown below:

                initexpr;

                while (testexpr)
                {
                  statement1;
                  postexpr;
                }

             11.8.3. Goto and Labels

             There are few cases when the preceding flow-control state-
             ments cannot be used to implement an arbitrary program struc-
             ture.  However, for those rare cases when the preceding
             statements are not sufficient, MEX provides a goto statement.

             The goto statement unconditionally transfers program control
             to a specific point in the program. The goto statement can be
             used to jump to another statement that either precedes or
             follows the goto statement itself, as long as the destination
             of the jump is within the same function as the goto.

             The goto statement is often said to be the antithesis of
             structured programming, but when used very sparingly, it can
             sometimes simplify error-handling or allow the programmer to
             exit a deeply-nested loop.

             A goto statement looks like this:

                goto label;

             where label is the user-defined destination for the jump.

             A label declaration looks like this:

                labelname:

             where labelname is an arbitrary name that follows these con-
             ventions:

             *  The name must be from 1 to 32 characters long.



             11. MEX Language Tutorial                                 193

             *  The name is case-sensitive. This means that "delta,"
                "Delta," "DELTA," and "DeLtA" refer to four distinct ob-
                jects.

             *  Names can include letters and underscores. Names can also
                include digits, except in the first character of the name.
                (This means that "top10" is a valid name, whereas "7up" is
                not.)

             The labelname is used to specify the destination in the goto
             statement. When the program encounters a "goto labelname"
             statement, it will immediately jump to the statement follow-
             ing labelname.

             The following code fragment demonstrates how goto is used to
             break out of a for loop:

                #include <max.mh>

                int main()
                {
                  int: i, sum;

                  // Start sum off at zero.

                  sum := 0;

                  // Count from 1 to 10

                  for (i := 0; i <= 10; i := i+1)
                  {
                       // Increment sum by the value of the counter.

                       sum := sum+i;

                       // If the count is at least 14, exit
                       // the loop.

                       if (sum >= 14)
                            goto out;
                  }

                out:
                  print(sum);
                  return 0;
                }

             There are much more elegant ways to implement this function,
             such as by moving the sum check into the testexpr of the for
             loop. Regardless, this code fragment shows how to add up all
             of the numbers from one to ten, but exiting the loop as soon
             as sum is greater than or equal to 14. (In the case above,
             sum will equal 15 when the loop finally terminates.)



             11. MEX Language Tutorial                                 194

             11.9. Function Calls

             As previously described in section 11.2.1, functions are the
             main building blocks of MEX programs. All MEX programs must
             contain a main function, but most programs will also have
             many other related functions. These functions are used to
             break a large problem down into smaller, more-manageable
             parts.

             In addition to the functions defined in the .mex source file,
             a large number of external functions can also be called by a
             MEX program. These functions perform various actions such as:
             displaying output to the user, prompting the user for input,
             accessing the Maximus user file, manipulating the file tag
             queue, and more. The code for these functions is contained
             within Maximus itself, but the functions can be called just
             like ordinary MEX functions declared in the source file. (A
             complete list of external functions is contained in section
             15.)

             In this section, the calling function refers to the point in
             the code from which a function call is made. The called func-
             tion refers to the destination of a function call, or the
             code that gets executed when the function call is performed.

             This section describes how to call functions, how to write
             your own functions, and how to pass data from one function to
             another.


             11.9.1. Calling Functions

             A function call looks like this:

                funcname(arglist);

             funcname is the name of the function to call. This name sim-
             ply identifies a function that has already been declared or
             defined in either the .mex source file or in the global
             max.mh header file.

             arglist is an optional, comma-delimited list of arguments to
             be used in the function call. Arguments are data objects that
             are shared between functions. Arguments allow the calling
             function to communicate with the called function, and vice
             versa.

             Although the comma-delimited list of arguments is optional,
             the pair of parentheses is not. Even if a function accepts no
             arguments, an empty pair of parentheses must follow the func-
             tion name.



             11. MEX Language Tutorial                                 195

             In the calling function, a function call can be written ei-
             ther as a separate statement (as shown above), or for func-
             tions that return values, the call can also be included in
             expressions. This is discussed in more detail in section
             11.9.4.

             Normally, arguments are used for one-way information transfer
             (to send information from the calling code to the function
             that is called), but if desired, the function arguments can
             also be used to transfer information in the other direction.

             The function call syntax should already be familiar, since
             the print function (as was used in many of the code segments
             given in prior sections) is just one example of a function
             call.

             When a MEX program encounters a function call, the following
             steps are taken:

             1. The current program location is saved.

             2. The arguments specified in arglist are copied so that the
                called function can access the information therein.

             3. Control is transferred to the called function. The state-
                ments in the called function are executed until it issues a
                return statement or executes the very last statement in the
                function.

             4. The program location is restored to the position saved in
                step 1.

             For example, the following example demonstrates how to se-
             quentially call a number of functions. (The declarations for
             these functions will be discussed in the following section.)

                #include <max.mh>

                // insert function definitions here

                int main()
                {
                  initialize_data();
                  open_file();
                  write_file();
                  close_file();
                  deinitialize_data();
                  return 0;
                }

             In this case, the main function is nothing but an empty shell
             that calls other functions. The above code instructs main to
             execute the statements in the initialize_data, open_file,



             11. MEX Language Tutorial                                 196

             write_file, close_file and deinitialize_data functions, in
             the order specified above.

             The called functions can also include function calls in their
             own code, and the functions called from there can also call
             other functions. In theory, an infinite number of function
             calls can be nested in this manner, but in practice, only a
             few dozen nested calls can be made at a time, depending on
             the size of the function arguments and the stack size speci-
             fied on the MEX command line.

             The print function is just one example of a function that re-
             quires arguments. Some functions can also accept multiple ar-
             guments, as shown below:

                #include <max.mh>

                // insert function definitions here

                int main()
                {
                  int: sailors;
                  int: yachts;

                  sailors := 8;
                  yachts := 2;

                  initialize_data(sailors, yachts);

                  sail_yacht_1(sailors / yachts);
                  sail_yacht_2(sailors - (sailors / yachts));

                  return 0;
                }

             The first two statements initialize the variables sailors and
             yachts to 8 and 2, respectively.

             The next statement is a function call to initialize_data. The
             two variables sailors and yachts are passed as arguments. In
             this hypothetical example, the initialize_data function pre-
             sumably uses these values to set up data structures describ-
             ing the number of sailors and the number of yachts that are
             in use.

             Next, the sail_yacht_1 function is called, with a number rep-
             resenting about half of the sailors. The function could use
             that information to determine how many sailors were in the
             boat's crew.

             Finally, the sail_yacht_2 function is called, using the num-
             ber of remaining sailors as an argument. The function would



             11. MEX Language Tutorial                                 197

             also presumably use the number of sailors to determine how it
             operates.

             As can be seen from the example above, although functions are
             used to break up the code of a program into smaller parts,
             the function argument list is how information is passed from
             one function to another.


             11.9.2. Defining Functions

             Previous sections have focused on calling external functions,
             or as-of-yet undeclared and undefined functions in the user
             code. This section describes how to define functions of one's
             own that can be called from other points in the program.

             A function definition has this form:

                return_type funcname(paramlist)
                {
                  statements
                }

             This definition can be broken down as follows:

             return_type is the type used for the function's return value.
             The return value is an optional piece of information that is
             passed back to the calling function. (If desired, the func-
             tion arguments can also be used to pass information back to
             the caller.) Not all functions have return values; when that
             is the case, the return_type is "void."

             funcname is the name of the function. This name is used when
             calling this function via a function call. Function names
             must abide by the following conventions:

             *  The name must be from 1 to 32 characters long.

             *  The name is case-sensitive. This means that "delta,"
                "Delta," "DELTA," and "DeLtA" refer to four distinct ob-
                jects.

             *  Names can include letters and underscores. Names can also
                include digits, except in the first character of the name.
                (This means that "top10" is a valid name, whereas "7up" is
                not.)

             paramlist is the optional, comma-delimited parameter list for
             the function. The parameter list consists of pairs of parame-
             ter types and parameter names. For functions that accept no
             parameters, the space within the parentheses must be left
             blank. The topic of function parameters is discussed in the
             following section in greater detail.



             11. MEX Language Tutorial                                 198

             The pair of braces delimit the body of the function. The
             statements contained therein can be any of the statement
             types described in previous sections.

             However, function definitions may not be nested. This means
             that function definitions must be placed at the "top level"
             of the source file, outside of any other function defini-
             tions.

             A simple function definition looks something like this:

                void hokey_pokey()
                {
                  print("bar\n");
                }

             This code defines a function called hokey_pokey. This func-
             tion can be called from the main function as shown below:

                int main()
                {
                  print("foo\n");
                  hokey_pokey();
                  print("boz\n");

                  return 0;
                }

             When run, this program will print:

                foo
                bar
                boz


             11.9.3. Function Prototypes

             If the called function is not defined in the same program
             source file as the calling function (such as with external
             functions), or if the function is defined later in the same
             file, the compiler must be told some extra information about
             the called function, including its argument types and return
             value.

             Regardless of whether a function is internal or external, the
             compiler needs some sort of information about the function ---
             either a function definition or a function prototype ---be-
             fore that function can be called.

             If an external function is called, a function prototype is
             required. If an internal function is called, and the defini-
             tion of that function occurs at a later point in the source
             file than the function call itself, a function prototype is



             11. MEX Language Tutorial                                 199

             also required. (If the called function is defined in the same
             file, and the definition occurs above the point in the file
             where it is called, a prototype is not required. In this
             case, the function definition provides sufficient information
             to the compiler.)

             A function prototype looks just like a function definition,
             except that the prototype has no function body. Instead, the
             statements and braces are replaced with a single semicolon.

             A function prototype looks like this:

                type funcname(paramlist);

             type is the return type of the function. This type must match
             the return type given in the function definition.

             funcname is the name of the function. This too should match
             the name of the function given in the function definition.

             paramlist is the parameter list for the function. Except in
             special cases with variable-parameter functions, this list
             should also match the parameter list given in the function
             definition.

             Function prototypes must be placed at the "top level" of the
             source file, outside of any other function definition, and
             before any attempt is made to call the function being proto-
             typed.

             Since a prototype tells the compiler about a function, before
             the definition for that function is presented, using proto-
             types allows two functions to call each other recursively:

                #include <max.mh>

                void func2();         // Prototype for func2

                void func1()
                {
                  func2();       // Call func2, even though it has
                                 // been declared. (The prototype
                                 // above tells the compiler about
                                 // func2 and the arguments/return
                                 // value that it accepts.
                }

                void func2()
                {
                  func1();       // Call func1. A prototype is not
                                 // required because the function
                                 // was defined at an earlier
                                 // point in the same file.



             11. MEX Language Tutorial                                 200

                }

             Note that for all of the external functions described in sec-
             tion 15, the appropriate function prototypes are already in-
             cluded in the max.mh include file. Hence, as long as the pro-
             gram contains the crucial "#include <max.mh>" line at the top
             of the file, all of the external functions will be automati-
             cally prototyped.


             11.9.4. Function Arguments


             11.9.4.1. Pass-By-Value Arguments

             Up until now, functions have been treated as if they were
             simply logical blocks of a program, performing the same pur-
             pose each time they were called. Function arguments allow
             functions to perform different actions depending on the val-
             ues of their arguments.

             An important distinction must be made between function argu-
             ments and function parameters. From the calling function, the
             variables specified when writing the function call are known
             as arguments. Within the called function, these arguments are
             referred to as parameters. This implies that the arguments
             that are "sent" by the calling function are equivalent to the
             parameters that are "received" by the called function.

             A function can accept as many parameters as desired; however,
             each parameter (and its associated type) must be specified
             when the function is defined and prototyped.

             A definition for a function that has parameters looks like
             this:

                type funcname(type1: var1, type2: var2)
                {
                  statements;
                }

             In this case, type1 is the type of the first parameter, and
             var1 is the name used to reference the parameter.

             Similarly, type2 is the type of the second parameter, and
             var2 is the name used to reference the second parameter.

             Naturally, more than two parameters can be used by simply ex-
             panding the comma-delimited list to provide more than two pa-
             rameter type/name pairs. The comma-delimited list is also
             known as the function's parameter list.



             11. MEX Language Tutorial                                 201

             A special word of caution is required for function parame-
             ters:

             All function arguments and parameters are positional. This
             means that the first parameter in a function definition must
             correspond to the first argument passed in a call to that
             function. Similar logic applies to the second and subsequent
             arguments and parameters.

             Also, the parameter names specified in the called function
             are simply "dummy names." The value to use for each parameter
             is provided by the argument list from the calling function.
             The calling function can pass any variable or expression for
             a given argument, but that value will become known to the
             called function by the parameter name specified in the func-
             tion definition.

             For example, given the following code:

                #include <max.mh>

                void myfunc(int: arg1, int: arg2)
                {
                  print("arg1 = ", arg1, " and arg2 = ", arg2, '\n');
                }

                int main()
                {
                  int: i, j;

                  i := 4;
                  j := 7;

                  myfunc(i, j);
                  return 0;
                }

             The program output will be:

                arg1 = 4 and arg2 = 7

             In the main function, the variable i is passed for arg1, and
             the variable j is passed for arg2. Within myfunc, the arg1
             and arg2 names refer to the parameters specified in the call
             to that function, regardless of what those arguments were
             called in the calling function.

             In myfunc, the value of arg1 will be equal to the value of i
             (from the main function), and the value of arg2 will be equal
             to the value of j (also from the main function).



             11. MEX Language Tutorial                                 202

             However, within the called function, changes made to the
             function parameters do not automatically cause a change in
             the arguments specified in the calling function.

             For example, given the following program:

                #include <max.mh>

                void change_it(int: a)
                {
                  a := 3;
                }

                int main()
                {
                  int: i;

                  i := 5;
                  change_it(i);
                  print("i is ", i, '\n');
                  return 0;
                }

             This program prints:

                i is 5

             As can be seen from the output, the assignment to a in
             change_it has no effect on the value of i in main.


             11.9.4.2. Pass-By-Reference Arguments

             MEX also supports a type of argument passing called pass-by-
             reference. Pass-by-reference arguments explicitly cause the
             argument passed into the function call to be modified when
             the parameter is updated from within the called function.

             To declare a pass-by-reference argument in the function defi-
             nition and prototype, simply include the ref keyword before
             the parameter type. For example, if the definition for
             change_it were modified to look like this:

                void change_it(ref int: a)

             then the program would display:

                i is 3

             as could be expected. The only caveat to using pass-by-
             reference arguments is that a variable must always be speci-
             fied for that argument when writing the function call, rather
             than using a constant or some other expression.



             11. MEX Language Tutorial                                 203

             This means that, given the pass-by-reference definition of
             change_it, the following function calls are illegal:

                change_it(3);           // 3 is a constant
                change_it(i * 2 + 2);   // i * 2 + 1 is an expression

             A function with pass-by-reference parameters will update the
             function argument if the parameter is changed from within the
             called function. Obviously, the function cannot change the
             "value" of the number 3. Likewise, it also cannot change the
             "value" of the expression "i * 2 + 1."

             Hence, arguments passed for pass-by-reference arguments must
             be simple variable names and not expressions or constants.


             11.9.5. Function Return Values

             In all of the examples presented in previous sections, the
             functions had no return value. A return value is another
             method that can be used to pass information from the called
             function back to the calling function.

             Function return values can be used in a manner similar to
             conventional mathematical functions. For example, if we had a
             function that calculated the square root of a number, one
             would like to be able to write:

                i := sqrt(25);          // i = 5

             To declare a function that returns a value:

             1. In the function prototype and definition, select an appro-
                priate return type for the function. This type must immedi-
                ately precede the funcname part of the definition or proto-
                type, as discussed in the preceding section.

             2. Inside the function, the return statement must be used to
                identify the value being returned.

             A return statement looks like this:

                return opt-expr;

             where opt-expr is an optional expression which has a type
             equivalent to the function return type.

             In those special cases where the function is declared as re-
             turning void, meaning that the function does not return a
             value, the opt-expr must not be present. If that is the case,
             the return statement must look like this:

                return;



             11. MEX Language Tutorial                                 204


             For functions that are declared as returning void, the return
             statement simply instructs the function to return immediately
             to the calling function. No data is passed from the called
             function to the caller.

             In cases where the function does return a value, upon encoun-
             tering a return statement, the program will take the expres-
             sion indicated in the return statement and store its value so
             that the calling function can access it. The program will
             then immediately return to the calling function.

             For example, to implement the square root function from
             above:

                int sqrt(int: value)  // the "int" before the sqrt
                {                // identifies the type of
                                 // return value.
                  int: result;

                  // Code here that calculates the square root
                  // of 'value' and places the result in 'result.'

                  return result;
                }

             In this case, the function is said to return the value that
             is contained in the result variable. The naming of the vari-
             able used in the return statement is completely arbitrary;
             the variable can be named anything, just as long as the re-
             turn statement indicates the value to be returned.

             However, the return statement need not always be at the very
             end of the function. Since the return function causes the
             program to immediately end the function being called, the re-
             turn statement is useful for error-checking and aborting a
             function before all statements have been executed.

             For example, to add a degree of error-checking to our func-
             tion:

                #include <max.mh>

                int sqrt(int: value)
                {
                  int: result;

                  if (value < 0)
                  {
                       print("Invalid sqrt() argument!\n");

                       return -1;  // No real-valued number will
                                 // have this root.



             11. MEX Language Tutorial                                 205

                  }

                  // Code to place the root of 'value' into 'result'.

                  return result;
                }

             In the case shown above, if an invalid argument is passed to
             the sqrt function, it will print an error message and return
             a value of -1. Otherwise, it will proceed with the calcula-
             tion and return the square root of the number.

             From this, one can see that the main function from previous
             examples is an ordinary function that returns an integer
             value. The only difference between main and other functions
             is that Maximus will check the return value from main, and if
             it is non-zero, Maximus will place an entry in the system
             log. (main is also the function that Maximus first calls when
             a MEX program is started.)

             However, functions are not constrained to returning only in-
             tegers. Functions can also be used to return data of types
             char, int, long and string. For example, to define a function
             that returns a string describing the day of the week:

                string weekday(int: daynum)
                {
                  if (daynum = 1)
                       return "Sunday";
                  else if (daynum = 2)
                       return "Monday";
                  else if (daynum = 3)
                       return "Tuesday";
                  else if (daynum = 4)
                       return "Wednesday";
                  else if (daynum = 5)
                       return "Thursday";
                  else if (daynum = 6)
                       return "Friday";
                  else if (daynum = 7)
                       return "Saturday";
                  else
                       return "*InvalidDay*";
                }

             Compared to previous examples in this section, the only sig-
             nificant changes are that the function return value is de-
             clared as "string," and the values following the return
             statements are all string constants.

             The main restriction with return values is that only one data
             item can be returned to the caller. However, if multiple data



             11. MEX Language Tutorial                                 206

             items need to be passed back to the caller, pass-by-reference
             arguments are the obvious solution.


             11.10. Arrays

             Programs often need to manipulate large amounts of informa-
             tion in a similar manner. If a program needed to manipulate
             500 numbers, the programmer could easily declare a variable
             to hold each individual number:

                int: num1;
                int: num2;
                int: num3;
                // and so on

             However, if all of the numbers represented similar pieces of
             information (such as, say, the height of an office building),
             an array can greatly simplify the code used to manipulate
             this information.

             An array is a data type that holds collections of other data
             objects. All of the objects contained within an array must be
             of the same data type.

             In addition, the objects within the array can be indexed. For
             example, given an array of 500 numbers, the program can ex-
             plicitly retrieve the 42nd number. Arrays can also be indexed
             by another variable. For example, the program can ask to re-
             trieve the ith number from within the structure, and if the
             integer variable i happens to contain the value 3 at run-
             time, the third object in the array is retrieved.

             Arrays can be considered as a group of data objects all lined
             up in a row. Each object in that row can be accessed indi-
             vidually by number, but the entire row can still be referred
             to as a single array of objects.


             11.10.1. Declaring Arrays

             An array declaration looks like this:

                array [lower .. upper] of type: varname;

             lower specifies the lower bound of the array. This is the
             lowest index value that can be used to store information in
             the array. Since most counting exercises start at the number
             one (as in first, second, third, and so on), this value is
             normally set to 1. (However, the code generated by the MEX
             compiler will run a little faster if the lower bound of the
             array is set to 0.)



             11. MEX Language Tutorial                                 207

             upper specifies the upper bound of the array. This is the
             highest possible index value that can be used to store infor-
             mation in the array. The value used for upper depends on the
             number of data items that need to be stored in the array. up-
             per must be greater than or equal to the value specified for
             lower.

             All of the values between lower and upper (inclusive) can be
             used as indices for the array. In general, the total number
             of data objects stored in the array can be calculated as fol-
             lows:

                Number of objects = upper - lower + 1

             A data object within an array is also sometimes referred to
             as an element in the array.

             type is the data type of the objects contained in the array.
             As discussed earlier, all of the objects in the array will
             have the same type.

             varname is the name of the array variable to be declared.
             varname must abide by the standard MEX variable-naming rules.

             For example, this declaration creates an array of 100 inte-
             gers:

                array [1 .. 100] of int: my_ints;

             In this case, the array variable is called my_ints, and valid
             index values are 1 through 100.

             Arrays of other data types can also be created; the indices
             for the array can also include negative values:

                array [-50 .. 50] of string: my_strings;

             Here, the array variable is called my_strings, and valid in-
             dex values are -50 through 50.


             11.10.2. Accessing Arrays

             Array variables themselves cannot be assigned or used in
             arithmetic expressions. However, the data objects within the
             array can be assigned to, manipulated, displayed, and treated
             like any other kind of variable.

             After having declared an array, the array operator is used to
             access an individual data object within the array. Within an
             expression, the array operator is used like this:

                arrayvar[idx]



             11. MEX Language Tutorial                                 208


             arrayvar is the name of a previously-declared array variable,
             such as my_ints or my_strings.

             idx is the index to be applied to the array, surrounded by
             square brackets. idx can be a constant (such as the number
             "4"), a variable (such as an integer), or the result of a
             more complex expression.

             This index value must always be within the bounds specified
             by upper and lower (from the array variable declaration). Us-
             ing an out-of-bounds index value results in undefined behav-
             ior.

             When used with the array operator, the arrayvar and idx vari-
             ables select a single data object from within the array. The
             array operator is always used as part of an expression. After
             applying the array operator, the resulting object can then be
             assigned to, manipulated as part of another expression,
             passed as a function argument, and treated like any other
             variable.

             For example, given the my_ints array declaration from above,
             the contents of the array can be set up as shown below:

                my_ints[1] := 42;
                my_ints[2] := 119;
                my_ints[3] := 55;
                // and so on

             However, as mentioned previously, the array index need not be
             a simple constant, as in the "1, 2, 3" case above. To ini-
             tialize all of the elements in the array to the value 42, a
             for loop can be used, along with an integer index:

                #include <max.mh>

                int main()
                {
                  array [1..100] of int: my_ints;
                  int: i;

                  // This 'for' loop increments 'i' from 1
                  // to 100.

                  for (i := 1; i <= 100; i := i + 1)
                  {
                       // Set each integer to 42.

                       my_ints[i] := 42;
                  }

                  return 0;



             11. MEX Language Tutorial                                 209

                }

             A more complicated expression can also be used as an index.
             For example, to initialize only even-numbered data objects:

                #include <max.mh>

                int main()
                {
                  array [1..100] of int: my_ints;
                  int: i;

                  // Note that 'i' goes from 1 to 50, since we
                  // are multiplying it by 2 below.

                  for (i := 1; i <= 50; i := i + 1)
                  {
                       // Initialize data objects indexed by i*2,
                       // which will result in indices of 2, 4,
                       // 6, 8, and so on.

                       my_ints[i*2] := 42;
                  }

                  return 0;
                }

             Similarly, the values in arrays can also be manipulated in
             other expressions. The following example creates an array
             containing the powers of 2:

                #include <max.mh>

                int main()
                {
                  array [1..8] of int: my_ints;
                  int: i;

                  for (i := 1; i <= 8; i := i + 1)
                  {

                       if (i = 1)
                            my_ints[1] := 1;
                       else
                            my_ints[i] := my_ints[i-1] * 2;

                       print("Array at ", i, " is ",
                             my_ints[i], '\n');
                  }

                  return 0;
                }



             11. MEX Language Tutorial                                 210

             11.10.3. Arrays as Function Parameters

             This section describes how to pass the information contained
             in arrays to other functions.


             11.10.3.1. Fixed-Length Arrays

             To pass information in an array to a function, one possible
             option is to pass each element in the array as a separate ar-
             gument, as shown below:

                array [1..100] of int: my_ints;

                // initialize array

                process_an_int(my_ints[1]);

             This example passes the first element of my_ints to the proc-
             ess_an_int function.

             However, the entire array can also be passed as a parameter
             in a function call. To do this:

             1. Ensure that the array types match. In the function proto-
                type and definition, the array parameter type must be iden-
                tical to the argument type that the caller provides in the
                function call. For example, if passing an array called
                "my_ints", and if my_ints has a type of "array [1..50] of
                string," this exact type definition must also be included
                in the function prototype and definition.

             2. Specify the name of the array variable when writing the
                function call. Just include the name of the array variable
                itself (without using the array operator).

             For example:

                #include <max.mh>

                void handle_ints(array [1..50] of int: my_array);

                int main()
                {
                  // Note that the type of the my_ints variable
                  // matches the type in the function prototype
                  // above.

                  array [1..50] of int: my_ints;

                  // initialize array here

                  handle_ints(my_ints);



             11. MEX Language Tutorial                                 211

                  return 0;
                }

                void handle_ints(array [1..50] of int: my_array)
                {
                  int: i;

                  // Now loop through all of the integers and
                  // display them.

                  for (i := 1; i <= 50; i := i + 1)
                       print("Int ", i, " is ", my_array[i], '\n');
                }

             The handle_ints function takes the my_array parameter and
             displays the value of every integer in the array.

             Unlike other types, arrays are always passed by reference.
             Even if no ref qualifier is present in the parameter list,
             any changes that the called function makes to the array will
             also be reflected in the caller's copy of the array.

             This allows a called function to adjust certain values in an
             array with little or no impact on program performance:

                #include <max.mh>

                void adjust_ints(array [1..50] of int: my_ints);

                int main()
                {
                  array [1..50] of int: foo;

                  // Initialize the array and display foo[2]

                  foo[1] := 3;
                  foo[2] := 8;
                  foo[3] := 9;

                  print("foo #2 is ", foo[2], '\n');

                  // Call adjust_ints and redisplay foo[2]

                  adjust_ints(foo);

                  print("foo #2 is ", foo[2], '\n');

                  return 0;
                }

                void adjust_ints(array [1..50] of int: my_ints)
                {
                  my_ints[2] := 4;



             11. MEX Language Tutorial                                 212

                }

             This program will display:

                foo #2 is 8
                foo #2 is 4


             11.10.3.2. Variable-Length Arrays as Function Parameters

             One common approach when using arrays is to write separate
             functions to manipulate the contents of an array of a speci-
             fied type. Unfortunately, even though arrays containing the
             same type of object are used in many places, not all of these
             arrays are guaranteed to have the same bounds.

             For example, suppose that we have two arrays containing the
             average daily temperature for each day in February and March
             (respectively). The arrays would be declared like this:

                array [1..28] of int: feb_temp;
                array [1..30] of int: mar_temp;

             Now, suppose that we want to print out all of the tempera-
             tures for a given month. For our first attempt, we try creat-
             ing a function with the following prototype:

                int print_temps(array [1..30] of int: month_temp);

             Unfortunately, even though we can call
             "print_temps(mar_temp)" using the above prototype, we get a
             MEX compile-time error if we try to call
             "print_temps(feb_temp)."

             This error occurs because the bounds of the declared array do
             not match the bounds of the array specified in the function
             prototype. Separate print_temps functions could be created
             with different array bounds, but this would lead to unneces-
             sary duplication of program code.

             To solve the problem in an elegant manner, MEX permits vari-
             able-length arrays in function prototypes and function defi-
             nitions. The lower bound for the array must still be speci-
             fied, and the lower bound must still match between the argu-
             ment and the parameter. However, the upper bound can be omit-
             ted. This tells MEX that the called function can accept an
             array of any length.

             A variable-length array can be declared as shown below. Note
             that this style of array declaration is only valid in func-
             tion parameter lists and prototypes:

                array [lower .. ] of type: varname



             11. MEX Language Tutorial                                 213


             The only difference between this format and the standard ar-
             ray declaration format is the absence of upper. Aside from
             this omission, the components of the two declaration formats
             are identical.

             Even though the upper bound can be omitted in the called
             function, it is still the called function's responsibility to
             ensure that the array is only accessed within a valid set of
             bounds. The array referenced by the parameter is the same ar-
             ray as was declared in the calling function. Consequently, if
             the original array had bounds of 5 to 10, the called function
             must not use an index outside of the 5 through 10 range when
             accessing the parameter. The conventional way to deal with
             this problem is to have the calling function pass an extra
             argument that indicates the bounds of the array.

             The following example shows how to use variable-length arrays
             to solve the "array of temperatures" problem discussed above:

                #include <max.mh>

                void print_temps(int: days,
                                 array [1..] of int: temps);

                int main()
                {
                  array [1..28] of int: feb_temp;
                  array [1..30] of int: mar_temp;

                  // Initialize the February array

                  feb_temp[1] := -15;
                  feb_temp[2] := -13;
                  // and so on

                  // Initialize the March array

                  mar_temp[1] := -3;
                  mar_temp[2] := 2;
                  // and so on

                  // Now print them both out:

                  print_temps(28, feb_temp);
                  print_temps(30, mar_temp);
                  return 0;
                }

                void print_temps(int: days, array [1..] of int: temps)
                {
                  int: i;



             11. MEX Language Tutorial                                 214

                  // Loop through all of the days in the array,
                  // as specified by the 'days' parameter, and
                  // print out the temperature for that day.

                  for (i := 1; i <= days; i := i + 1)
                  {
                       print("Temperature for day ", i, " is ",
                             temps[i], '\n');
                  }
                }


             11.11. Structures

             When a function must manage a large amount of information, it
             is often helpful to group that information together in a
             logical manner. For example, to design an electronic address
             book, one possible (but clumsy) approach is to declare a
             separate variable for each item in the address book, like
             this:

                string: name;
                string: address;
                string: city;
                string: province;

             Then, every time a data record needed to be read in or writ-
             ten out, each variable could be manipulated separately. Simi-
             larly, every time a function needed to access information in
             the address record, each variable would need to be passed as
             a separate parameter.

             However, MEX provides a much easier way to group variables.
             The structure is an aggregate data type that acts as a
             "container" for other variables.

             Structure variables (which are simply variables that are de-
             clared of the structure type) can then be manipulated, as-
             signed and copied as a single data object. These actions act
             upon all of the fields contained within the structure. If de-
             sired, the fields within the structure can also be accessed
             individually.

             Unlike arrays, structures can contain objects of different
             data types. Because of this, there is no way to specify an
             integer "index" to obtain a particular data object that is
             contained within the structure. (However, one can construct
             an array of structures; see section 11.11.4 below for more
             information.)



             11. MEX Language Tutorial                                 215

             11.11.1. Defining Structure Types

             Before a structure variable can be declared, the format of
             the structure itself must be defined. For example, in the ad-
             dress book example, we would need to tell the compiler that
             an "address book structure" contained the four string vari-
             ables mentioned above.

             The definition of a structure type looks like this:

                struct tag
                {
                  field-decl-list
                };

             Structure definitions must be placed at the top of the source
             file, outside of any function definition.

             tag is an arbitrary, user-defined "tag" for the structure.
             The tag identifies a particular structure type and its con-
             tents. A program can use many different structure types at
             the same time ---such as both an address book structure and a
             phone book structure, as could be envisaged for our example
             above ---so the tag is needed to differentiate between dif-
             ferent structure types.

             The tag can be set to any arbitrary name, as long as the name
             is unique among other functions, global variables and struc-
             tures. The tag is used later when declaring variables of the
             specified structure type. The tag name must also abide by the
             usual variable-naming conventions:

             *  The name must be from 1 to 32 characters long.

             *  The name is case-sensitive. This means that "delta,"
                "Delta," "DELTA," and "DeLtA" refer to four distinct ob-
                jects.

             *  Names can include letters and underscores. Names can also
                include digits, except in the first character of the name.
                (This means that "top10" is a valid name, whereas "7up" is
                not.)

             The field-decl-list contains a number of field definitions. A
             field is simply a data object contained within the structure.
             In our example at the beginning of the section, the name and
             address variables are fields in the address book structure.

             A single semicolon must follow the closing brace of the
             structure.

             The field-decl-list looks exactly like a variable declaration
             block at the beginning of a function. For example, if we were



             11. MEX Language Tutorial                                 216

             to give our address book structure a tag of "abook," the
             definition would look like this:

                struct abook
                {
                  string: name;
                  string: address;
                  string: city;
                  string: province;
                };

             This structure definition has a tag of abook, and the struc-
             ture contains the fields name, address, city and province.

             However, as with variable declaration blocks, the fields in a
             structure need not all be of the same type. Our address book
             could be expanded to include more useful information, as
             shown below:

                struct abook
                {
                  string: firstname;  // "John"
                  char: initial;      // 'Q'
                  string: lastname;        // "Public"

                  int: house_number;  // 777
                  string: street;          // Downing St.
                  string: city;       // Kingston
                  string: province;        // Ontario
                };

             This structure contains a number of string variables as be-
             fore, but it also contains an int and a char to store indi-
             vidual pieces of the address information.

             This structure type definition will be used by several exam-
             ples in the following sections. This type definition should
             be included in any source file that uses the abook structure.


             11.11.2. Declaring Structure Variables

             Once a structure type has been defined, variables of that
             structure type can be created. Just like a normal int (or
             other variable type), structure variable declarations are
             placed in the variable declaration block at the beginning of
             a function.

             A structure variable declaration looks like this:

                struct tag varname;



             11. MEX Language Tutorial                                 217

             The tag refers to a structure tag that was previously de-
             clared in a structure type definition.

             varname is the name of the structure variable to be declared.

             Given our address book example, suppose that we wanted to
             create two entries in the address book. We could then declare
             two structure variables as follows:

                struct abook: john;
                struct abook: steve;

             This would create variables called john and steve, each con-
             taining distinct copies of the fields in the address book
             structure.


             11.11.3. Using Structure Variables

             For the most part, structure variables can be manipulated
             like other data types. While it is obviously not possible to
             use arithmetic operators on entire structures (what would
             "steve + john" mean?), these structure variables can be as-
             signed, passed as parameters in function calls, and so on.

             In addition to the standard operators, the field selector op-
             erator ("." ---a period) is a special operator that can only
             be used with structures. This operator is used to directly
             access a single field contained within a structure.

             Within an expression, the field selector operator is used
             like this:

                structvar . field

             structvar is the name of a previously-declared structure
             variable, such as "john" (from our previous example).

             Following the period ("."), the field is the name of one of
             the fields declared in the original structure definition,
             such as "firstname" or "street."

             By applying the field selector operator to a structure vari-
             able and a field name, single fields within the structure can
             be manipulated individually.

             The field selector operator is always used as part of an ex-
             pression. In other words, after applying the field selector
             operator to a structure variable and a field name, the result
             is always assigned to another variable, used as the target of
             an assignment, or included in some other expression.



             11. MEX Language Tutorial                                 218

             For example, given an address book structure named john, we
             can assign a value to one of its fields like this:

                john.lastname := "Public";

             It may be useful to think of the structure operator as a way
             to select a certain field from a structure (which can then be
             used in the following operation).

             After using the field selector, the result is an object which
             has a type equivalent to the type of the field. With our ad-
             dress book example, if we had declared a structure variable
             called john, the object "john.firstname" has a type of
             string. This means that john.firstname can be manipulated
             just like any other string.

             In addition to assigning a string to john.lastname, as we did
             above, the following type of manipulation is also perfectly
             acceptable:

                fullname := john.firstname + " " + john.lastname;

             This expression takes the firstname field (which is a string)
             from within the john structure, and it then uses the catena-
             tion operator to add a space, followed by the contents of
             john.lastname.

             The following sample program shows how values can be assigned
             to and retrieved from fields in a structure:

                #include <max.mh>

                struct abook
                {
                  string: firstname;
                  char: initial;
                  string: lastname;

                  int: house_number;
                  string: street;
                  string: city;
                  string: province;
                };


                int main()
                {
                  struct abook: john;
                  struct abook: steve;

                  john.firstname     := "John";
                  john.initial       := 'Q';
                  john.lastname      := "Public";



             11. MEX Language Tutorial                                 219

                  john.house_number  := 777;
                  john.street        := "Downing St";
                  john.city          := "Kingston";
                  john.province      := "Ontario";

                  steve.firstname    := "Steve";
                  steve.initial      := 'S';
                  steve.lastname     := "Smith";
                  steve.house_number := 5;
                  steve.street       := "Smith St";
                  steve.city         := "Smiths Falls";
                  steve.province     := "Ontario";

                  print("John's last name is ",john.lastname,'\n');
                  print("Steve's last name is ",steve.lastname,'\n');

                  return 0;
                }

             This sample program should print:

                John's last name is Public
                Steve's last name is Smith


             11.11.4. Advanced Structure Definitions

             Structures can be used to store simple data types, such as
             int, char, string and long, but structures can also be used
             to store arrays and even nested copies of other structures.

             Structures containing other structures or arrays are declared
             in the same manner as less-complicated structures. In the
             case of structures containing structures, as long as the
             "child" structure (to be included within the "parent" struc-
             ture) is defined at an earlier point in the source file
             (relative to the parent definition), the structure definition
             can be written as one might expect:

                struct date
                {
                  int: year, month, day;
                };

                struct addressbook2
                {
                  string: name;
                  struct date: date_entered;
                  struct date: date_updated;
                  array [1..2] of string: phone;
                };



             11. MEX Language Tutorial                                 220

             This example uses a child structure, date, contained within
             the parent structure, addressbook2. The parent structure con-
             tains two copies of the date structure, called date_entered
             and date_updated. It also includes an array of strings for
             storing data and FAX phone numbers.

             The structure member operator (".") and array operators ("["
             and "]") can be combined in a logical manner to access the
             fields within these structures.

             The address book structure from above can be declared and
             used like this:

                struct addressbook2: john;

                john.name := "John Q. Public";   // standard field

                john.date_entered.year  := 1995; // nested field
                john.date_entered.month := 6;    // nested field
                john.date_entered.day   := 18;   // nested field

                john.date_updated.year  := 1995; // nested field
                john.date_updated.year  := 7;    // nested field
                john.date_updated.day   := 14;   // nested field

                john.phone[1] := "+1-613-389-8315"; // array field
                john.phone[2] := "+1-613-634-3058"; // array field

             Other advanced constructs can also be used. For example, an
             array of structures can be declared to hold an entire address
             catalog. Fields within the structures can then be accessed
             like this, assuming the addressbook2 definition from above:

                array [1..10] of struct addressbook2: book;

                book[1].name := "Steve S. Smith";
                book[1].date_entered.year := 1995;
                book[1].phone[1] := "+1-613-634-3058";
                // etc.

                book[2].name := "John Q. Public";
                book[2].date_entered.year := 1995;
                book[2].date_updated.month := 6;
                // etc.

             This makes it possible to perform the same operations on many
             structures, which has many applications in data processing
             programs. For example, given the address book definition from
             above, the following program segment could be used to print
             out the names of everyone in the address book:

                int: idx;



             11. MEX Language Tutorial                                 221

                for (idx := 1; idx <= 10; idx := idx + 1)
                {
                  // If the name in this address book record is
                  // not empty, print it out.

                  if (book[idx].name <> "")
                       print("Name is ", book[idx].name, '\n');
                }

             11.11.5. Structures as Function Parameters

             Structures can also be passed as parameters to functions.
             Just like other variable types, the contents of the struc-
             tures can be accessed from within the called function using
             standard syntax.

             In the function prototype and function definition, simply in-
             clude the variable type and name in the parameter list. (For
             example, "struct addressbook: mybook" could be added to the
             parameter list to specify an address book structure.)

             Next, when writing the function call, just include the name
             of the structure variable to be passed to the caller. For ex-
             ample:

                #include <max.mh>

                struct date
                {
                  int: year, month, day;
                };

                // Prototype for the function declared below.

                void showdate(struct date: d);

                int main()
                {
                  struct date: d1, d2;

                  // Initialize dates

                  d1.year := 1995;
                  d1.month := 7;
                  d1.day := 1;

                  d2.year := 1994;
                  d2.month := 3;
                  d2.day := 24;

                  // Display them to the user

                  showdate(d1);



             11. MEX Language Tutorial                                 222

                  showdate(d2);

                  return 0;
                }

                void showdate(struct date: d)
                {
                  print(d.month, '/', d.day, '/', d.year, '\n');
                }

             Upon running the above program, the following is displayed:

                7/1/1995
                3/24/1994

             However, like arrays, structures are always passed by refer-
             ence, regardless of whether or not the ref qualifier is used.
             This means that the called function will always be able to
             modify the contents of the structure passed in by the parent.
             For example:

                #include <max.mh>

                struct date
                {
                  int: year, month, day;
                };

                void changeit(ref struct date: d)
                {
                  d.year := 1993;
                }

                int main()
                {
                  struct date: d;

                  d.year := 1995;
                  d.month := 4;
                  d.day := 16;

                  print(d.month, '/', d.day, '/', d.year, '\n');
                  changeit(d);
                  print(d.month, '/', d.day, '/', d.year, '\n');

                  return 0;
                }

             This sample program will print:

                4/16/1995
                4/16/1993



             11. MEX Language Tutorial                                 223

             11.12. Casts

             A cast is an explicit instruction to the MEX compiler to con-
             vert a data object from one type to another. Casts are not
             required for most MEX programs, but they are useful in some
             situations.

             A cast is used within an expression like this:

                 (type) argument

             argument is the expression or object that is to be converted.

             type is the type to which argument is to be converted. MEX
             currently only allows programs to cast to or from the char,
             int, and long types.

             For example, the following code segment converts a char so
             that it can be assigned to a long:

                char: c;
                long: l;

                c := 'A';

                l := (long)c;         // l now contains 65, the ASCII
                                 // value of 'c'.

             In many cases, casting is not necessary. In the example
             above, MEX would perform an implicit type conversion anyway
             if the cast were not specified. The following line would have
             exactly the same effect:

                l := c;          // perform implicit conversion
                                 // from char to long.

             However, casts are sometimes used when calling the print
             function to display output of a certain type. The print func-
             tion is type-sensitive, meaning that it produces different
             forms of output depending on the type of data object that is
             passed to it.

             For example, if we have the following code:

                #include <max.mh>

                int main()
                {
                  char: c;
                  int: i;
                  long: l;

                  c := 65;



             11. MEX Language Tutorial                                 224

                  i := 65;
                  l := 65;

                  print(c, '\n');
                  print(i, '\n');
                  print(l, '\n');

                  return 0;
                }

             The program will display the following output:

                A
                65
                65

             The number 65 is the ASCII value of the letter `A', and since
             print knows that it is displaying a character, the first line
             in the output is the character representation of c.

             Likewise, print knows when it is displaying integers and long
             integers, so it formats the output appropriately.

             Casting is useful when you have an object of one data type
             but wish it to be displayed as an object of another type.

             For example, suppose that we actually wanted our program to
             display the ASCII value of c. We could then rewrite that one
             line like this:

                print( (int)c, '\n' );

             which would produce the desired output of "65." The cast con-
             verts the character to an integer, so when print goes to dis-
             play the object, it applies the standard integer formatting
             rules.

             Likewise, casts can be useful when dealing with signed and
             unsigned integers. MEX stores negative numbers using the
             standard two's complement notation; this means that "-1" is
             represented (in a 16-bit int) as 65535; "-2" is represented
             as 65534; and so on.

             If your program reads in a value as an unsigned integer but
             wishes to display the signed representation of that number,
             the following code can do the job:

                #include <max.mh>

                int main()
                {
                  unsigned int: ui;



             11. MEX Language Tutorial                                 225

                  // Code to read the integer would go here. For this
                  // example, we just assign an unsigned value to the
                  // 'ui' variable.

                  ui := 65532;

                  print("Unsigned is ", ui, '\n');
                  print("  Signed is ", (int)ui, '\n');

                  return 0;
                }

             This code will display:

                Unsigned is 65532
                  Signed is -4

             Likewise, a similar cast can be used to convert a negative
             signed number into the standard two's-complement (unsigned)
             representation.


             11.13. Further Explorations in MEX

             This completes the MEX language tutorial. While far from a
             comprehensive programming design manual, this section should
             have given you an overview of the capabilities of the MEX
             language, and it should have also given you some ideas for
             writing programs of your own.

             From here, the best thing to do is to try writing some MEX
             programs. After you feel comfortable with the basics of the
             MEX language, also have a look at section 13 later in this
             document.

             In that section, a number of helpful interfacing tips are
             presented for writing MEX programs that interface with the
             internal Maximus functions and data structures. Since the
             goal of writing MEX programs is typically to extend the func-
             tionality of Maximus in some way, section 13 is a valuable
             resource.

             Also, section 15 will also prove to be useful for first-time
             MEX programmers. That section describes how to use all of the
             functions in the MEX run-time library; you will probably find
             that many of these functions come in handy when writing your
             own MEX programs, so it pays to know what is in the run-time
             library before you start writing.

             Good luck in the world of MEX programming!








                                       12. MEX for C and Pascal Programmers

             This section serves as a brief summary of the MEX language
             for intermediate programmers. A familiarity is assumed with
             either the C or the Pascal programming language.

             This section is very much a "whirlwind tour" of the concepts
             used in the MEX language. The details given below are proba-
             bly not enough to allow a C or Pascal developer to start pro-
             gramming in MEX right away.

             Instead, this section should be used as a list of key MEX
             features that are similar to or different from other lan-
             guages. Much more detailed explanations of these key concepts
             can be found in section 11.


             12.1. Comments

             A comment is started by the two-character sequence "//" and
             continues until the end of the line. This concept is borrowed
             from C++ (and indirectly from BCPL).


             12.2. Include Files

             MEX borrows the "include file" concept from the C language.
             The #include directive instructs MEX to read in the named
             file and process it as if it were included directly in the
             source file.

             The following line must be present at the top of each MEX
             file designed to interface with Maximus:

                #include <max.mh>


             12.3. Blocks

             For denoting logical blocks within a function, MEX uses the
             "{" and "}" characters, as in C. These are equivalent to the
             "begin" and "end" keywords in Pascal.


             12.4. Function Definitions

             As in C, a subprogram in MEX is always called a function. A
             "procedure" is equivalent to a function that returns void.

             A function definition looks like this:



             12. MEX for C and Pascal Programmers                      228

                returntype name (param-list)
                {
                  // body goes here
                }

             where returntype is the return type of the function, name is
             the name of the function to be defined, and param-list is a
             comma-delimited list of function parameters.


             12.5. Types

             MEX supports the following types: char, int, long, string,
             struct, array, and void. char, int, and long are integral
             data types. struct and array are aggregate data types that
             contain many data objects. void is a special data type used
             only for function return values and ref void function parame-
             ters.

             Both signed and unsigned versions of the three integral types
             can be declared. Without an explicit signed or unsigned type
             qualifier, the char type is unsigned, while both int and long
             are signed by default.

             The char, int, long, struct and void types are borrowed from
             C.

             The array type is borrowed from Pascal.

             The string type is borrowed from BASIC.


             12.6. Variable Declarations

             A single variable declaration looks like this:

                type: name-list;

             type can be one of the standard type names, including char,
             int, long, and string. type can also be an array type ("array
             [lower .. upper] of type") or a structure type ("struct
             tag"). The type name is always followed by a colon (":").

             name is a comma-delimited list describing the names of the
             variables to be declared. The variable name must abide by
             these conventions:

             *  The name must be from 1 to 32 characters long.

             *  The name is case-sensitive. This means that "delta,"
                "Delta," "DELTA," and "DeLtA" refer to four distinct ob-
                jects.



             12. MEX for C and Pascal Programmers                      229

             *  Names can include letters and underscores. Names can also
                include digits, except in the first character of the name.
                (This means that "top10" is a valid name, whereas "7up" is
                not.)

             The variable declaration syntax is a mix of both C and Pascal
             declaration styles. Multiple variables declarations can be
             placed in a block after any opening brace in a function. No
             keywords are required to define the start or end of a vari-
             able declaration block; the compiler recognizes the declara-
             tions by context.

             A sample function that declares two strings and an integer is
             given below:

                void myfunc()
                {
                  string: str1, str2;
                  int: myint;

                  // function code goes here
                }

             12.7. Function Prototypes

             Before a function may be called, a prototype must be declared
             that lists the function return value, name, and parameter
             list. This concept is similar to the C++ "prototype" and the
             Pascal "forward declaration." (However, if the function is
             defined at a point in the same source file above the call to
             that function, no prototype is required.)

             A function prototype looks just like a function definition,
             except that the "{" and "}" of the function body are replaced
             by a single semicolon (";").


             12.8. Function Return Values

             As in C, values are returned by functions using the return
             keyword. This differs from Pascal where the function return
             value is set by "assigning" a value to the name of the func-
             tion.


             12.9. Strings

             MEX supports dynamic strings, as in BASIC. When declaring a
             string, no explicit string length need be defined. Similarly,
             strings can be catenated, assigned, and otherwise manipulated
             without worrying about the length of the string.



             12. MEX for C and Pascal Programmers                      230

             Individual characters can be retrieved from (and inserted
             into) a string using the "str [ idx ]" operator, where str is
             a string variable and idx is an integer specifying the char-
             acter number to be modified, where an idx of 1 represents the
             first character in the string.

             The length of a string can be determined using the strlen
             function in the MEX run-time library. A number of other
             string-processing functions can also be found in the run-time
             library.


             12.10. Compound Statements

             MEX borrows the concept of compound statements from C. At any
             point in the language where a single statement is accepted, a
             group of n statements (or a compound statement) can be speci-
             fied as shown below:

                {
                  stmt1;
                  stmt2;
                  // ...
                  stmtN;
                }

             A compound statement begins with a left brace and ends with a
             right brace. Any number of statements can be contained. Com-
             pound statements can be nested.


             12.11. Arithmetic, Relational and Logical Operators

             MEX borrows concepts from both C and Pascal in this area.

             The assignment and equality operators are borrowed from Pas-
             cal. To assign a value to a variable, use the ":=" operator.
             To test if two variables are equal, use the "=" operator.

             The equality operator can operate upon all data types except
             array, struct and void.

             The assignment operator can operate upon all data types ex-
             cept array and void.

             The other arithmetic, relational and logical operators can
             operate only on the three integral data types, char, int and
             long. The "+" operator can also be used to catenate strings.



             12. MEX for C and Pascal Programmers                      231

             12.12. The for Statement

             MEX borrows the syntax for the for statement from the C lan-
             guage. The syntax is:

                for (init-expr; test-expr; post-expr)
                  statement

             init-expr is evaluated only once (before any other part of
             the loop is executed).

             test-expr is evaluated every time the loop is executed, be-
             fore the first statement in the loop body is processed. The
             loop exits when test-expr equals zero.

             post-expr is evaluated after every iteration of the loop.

             statement is the statement (or compound block) that is per-
             formed every time the loop is executed.


             12.13. Arrays

             MEX uses a Pascal-like syntax for declaring arrays:

                array [lower .. upper] of type: varname;

             lower is the lower bound of the array. This value must be an
             integer.

             upper is the upper bound of the array. This value must be an
             integer.

             type is the base type used for the data objects within the
             array.

             varname is the name of the variable to be declared.

             Data objects within an array can be accessed using the stan-
             dard array operator notation ("[" and "]"). The index value
             specified within must be of an integral type: either char,
             int, or long.


             12.14. Pointers

             MEX does not support pointer variables.



             12. MEX for C and Pascal Programmers                      232

             12.15. Pass-By-Reference Arguments

             As in Pascal, arguments passed to a function can be passed by
             reference. This allows the called function to modify the
             value of the argument specified by the caller.

             To use a pass-by-reference argument, the ref keyword is in-
             cluded before the variable type in the function's parameter
             list, for both the function prototype and the function defi-
             nition.


             12.16. Variable-Length Arrays

             In a function parameter list, MEX allows the programmer to
             omit the upper bound for an array declaration. This allows
             functions to accept variable-length arrays:

                int process_array(array [1..] of int: my_array,
                                  int: size_of_my_array)
                {
                  // process my_array here
                }

             12.17. Structures

             MEX uses the C syntax for declaring and defining structures.
             (Structures are conceptually similar to the Pascal "record"
             type.) Before using a structure, the structure type must be
             defined as shown below:

                struct tag
                {
                  decl-list
                };

             tag is the tag name associated with this structure type.

             decl-list contains a block of declarations which define the
             objects contained within the structure. This decl-list is
             identical to a variable declaration block in terms of syntax.

             To declare a structure variable, the following syntax is
             used:

                struct tag: varname;

             This declaration instantiates a structure of the previously-
             defined tag type, creating a structure variable with name
             varname.

             To access a field within a structure, the structure member
             operator (".") is used. For example, if the structure foo



             12. MEX for C and Pascal Programmers                      233

             contained a field called my_string (of type string), a value
             could be assigned to that field as follows:

                foo.my_string := "String to go into the foo struct.";

             12.18. Run-Time Library Support

             MEX supports an extensive run-time library that performs ba-
             sic I/O tasks and data manipulation. The run-time library
             also includes numerous interfaces to internal Maximus func-
             tions.








                                           13. Interfacing MEX with Maximus

             This section describes various issues related to interfacing
             MEX programs with Maximus. While all MEX programs must be run
             under Maximus, this section concentrates on those programs
             that tie into special Maximus-specific features and func-
             tions.


             13.1. User Information

             Maximus creates a number of important data structures that
             can be accessed by a MEX program. Of these structures, the
             most important is the user structure. Maximus creates a
             global variable called usr which contains a copy of informa-
             tion about the current user.

             The usr variable is accessible to any MEX program that con-
             tains the "#include <max.mh>" line at the top of the source
             file.

             The usr structure contains everything that Maximus knows
             about the current user, including the user's name, privilege
             level, key settings, date of the user's last call, and more.

             In general, this structure can be read from or written to at
             will. For example, to display a personal greeting to the
             user:

                print("Hello there, ", usr.name, ", how are you?\n");

             If the user was called Steve Smith, the above line would dis-
             play:

                Hello there, Steve Smith, how are you?

             Similarly, other fields in the user structure can be accessed
             or displayed:

                print("You come from ", usr.city, " and you have "
                      "these keys: ", usr.xkeys, '\n');

             If the user's city field was set to "Smith Falls," and if the
             user had keys 1, 2, and C, the following would be displayed:

                You come from Smith Falls and you have these keys: 12C

             Most variables in the user record can also be modified. For
             example, the following line will give key "D" to the current
             user and adjust the user's privilege level to 40:



             13. Interfacing MEX with Maximus                          236

                usr.xkeys := usr.xkeys + "D";
                usr.priv := 40;

             Most of the other fields in the user file can be accessed in
             a similar manner. For example, the usr.ludate structure can
             be used to determine the date of the user's last call. From
             there, the stamp_to_long function could be used to convert
             that structure into a long, which could then be compared with
             the current date to determine how many seconds had elapsed
             since the user's last call.

             Section 15 contains a list of all global data structures and
             their contents, including all of the fields in the user
             structure.


             13.2. Message Area Information

             Maximus stores information about the current message area in
             two places: in a structure called marea, which contains
             static information about the area itself, and it also stores
             data in a secondary structure called msg, which contains in-
             formation about the status of the area and the user's current
             message.

             As before, these structures are defined in the max.mh include
             file.

             The following code is used to display the name of the current
             message area:

                print("You are in the ", marea.name, " area.\n");

             Unlike the user structure, the information in the marea
             structure cannot be changed.

             The msg structure can also be used to display information
             about the area that is relevant to the user. For example, to
             display the user's current message:

                print("You just read message #", msg.current, '\n');

             The msg structure also contains information on the number of
             messages in the area and the highest message number. The
             msg.current field can be adjusted to change the current mes-
             sage number, but the other fields must not be modified.

             As before, information on the formats of these structures can
             be found in section 15.



             13. Interfacing MEX with Maximus                          237

             13.3. File Area Information

             Similarly, information on the current file area can be found
             in the farea structure. Just like the marea structure, it
             must not be modified by MEX programs.


             13.4. Changing Message and File Areas

             The msg_area and file_area functions display a list of areas
             and prompt the user to select a new area. The msgareaselect
             and fileareaselect functions explicitly move the user to a
             specific message or file area.


             13.5. Displaying Output

             The standard MEX output function, print, is also used for
             most user-related display tasks. The full set of AVATAR color
             and cursor controls is available to MEX programs through this
             function.

             Some of the AVATAR sequences, such as simple color-changing
             commands, have already been predefined in max.mh. To use
             them, simply include the appropriate macro in your program
             source. For example, to display different parts of the text
             in white or green:

                print(COL_WHITE "This text is displayed in white, "
                      "but this text " COL_GREEN "here" COL_WHITE
                      "is shown in green.\n");

             If the constant for the color you wish to use is not defined
             in one of the COL_* constants in max.mh, please see the AVA-
             TAR_ATTR sequence in the table below:

             Some of the other predefined AVATAR sequences are shown in
             Table 13.1:

             Table 13.1 AVATAR Control Sequences

              Command          Description

              AVATAR_ATTR      Set the current color based on the char-
                               acter following the AVATAR_ATTR sequence.
                               This character is encoded using the stan-
                               dard AVATAR color number, as given in
                               Appendix F. Do not forget to cast this
                               number to a char, as shown in the example
                               following this table.
              AVATAR_BLINK     The following text will blink. The blink-
                               ing attribute remains active until the
                               next AVATAR color command.



             13. Interfacing MEX with Maximus                          238

              AVATAR_UP        Move the cursor up by one line.
              AVATAR_DOWN      Move the cursor down by one line.
              AVATAR_LEFT      Move the cursor left by one column.
              AVATAR_RIGHT     Move the cursor right by one column.
              AVATAR_CLEOL     Clear from the cursor to the end of the
                               line, using the currently-selected at-
                               tribute.
              AVATAR_GOTO      Move the cursor to a specified location.
                               The next two characters following the
                               AVATAR_GOTO sequence must indicate the
                               row and column, respectively. (The two
                               following row/column values must be
                               casted to the char type. Casting is de-
                               scribed in section 11.12.)
              AVATAR_CLS       Clear the screen, move the cursor to row
                               1, column 1, and set the current color to
                               cyan.


             Based on the user's video setting, these AVATAR codes will be
             either sent as-is, translated into ANSI codes, or stripped
             from the display stream, depending on the user's graphics ca-
             pabilities. This translation is performed automatically by
             Maximus.

             As an example of graphics capabilities, this code clears the
             screen, moves the cursor to row 5, column 6, sets the color
             to light green, and then displays the text "Hello."

                print(AVATAR_CLS AVATAR_GOTO, (char)5, (char)6,
                      COL_LGREEN "Hello.\n");

             To demonstrate the AVATAR_ATTR sequence, the following code
             changes the current color to light red on blue. By consulting
             the AVATAR color table in Appendix F, we see that light red
             on blue is color 28, so we proceed as follows:

                print(COL_WHITE "This is a " AVATAR_ATTR, (char)28,
                      "gaudy" COL_WHITE " color.\n");

             13.6. Retrieving Input

             Maximus supports a number of functions which retrieve input
             from the user. Of these functions, the most commonly-used are
             input_str, input_list and input_ch.

             These functions use the same interface that Maximus itself
             uses for retrieving input. These functions can all display
             prompts and perform special actions depending on what the
             calling code requires:

             The input_str function is used to get either a single word or
             an entire string from the user.



             13. Interfacing MEX with Maximus                          239

             The input_list function prompts the user to enter a character
             from a specified list of choices. This is used internally for
             the "More [Y,n,=]?" prompt and also for most other questions
             that require single-character responses.

             The input_ch function obtains a single character from the
             user. This function can also interpret the "scan codes" used
             by terminal programs that support the "DoorWay" protocol.

             Also, the getch function is used to perform raw character in-
             put. It retrieves a character directly from the user, without
             going through the command stacking buffer or displaying any
             prompts.


             13.7. File I/O

             For manipulating files on disk, a number of run-time library
             functions come in handy. open, read, write, seek, tell and
             close are useful for reading, writing, and updating the con-
             tents of files. fileexists and filesize are used to determine
             general information about named files. And the filefind*
             functions can be used to expand wildcards to find files in a
             directory tree.


             13.8. Menu Commands, Displaying Files and External Programs

             The menu_cmd and display_file functions are used to run in-
             ternal Maximus menu commands and display .bbs files, respec-
             tively.

             The shell function spawns an external program, such as a
             .exe, .bat, or .cmd file.


             13.9. Download Queue

             The tag_queue_file function is used to add a file to the
             download queue. The other tag_queue_* functions also allow a
             MEX program to retrieve information about existing files in
             the queue.

             To send a file to the user, the program must first queue the
             file using tag_queue_file. Next, it must call menu_cmd and
             instruct it to run the internal MNU_FILE_DOWNLOAD menu op-
             tion. This will initiate the normal download sequence. Maxi-
             mus will prompt the user for a protocol if necessary, and it
             will also allow the user to select other files to download.

             If this behavior is not desired, the MEX program can:



             13. Interfacing MEX with Maximus                          240

             *  Set the usr.def_proto field to one of the PROTOCOL_* con-
                stants in max.mh. This causes Maximus to skip the "Select
                protocol:" prompt and forces the user to download using a
                specific protocol.

             *  Insert a "|" into the input global variable. This adds a
                carriage return to the stacked input string, so the
                "File(s) to download (#2):" prompt will be skipped and the
                file will be sent immediately.


             13.10. Other Functions

             While this section has touched on the major functions that
             are used to interface with Maximus, many of the other func-
             tions in the run-time library can be used to modify Maximus's
             internal behavior. Please consult the function list in sec-
             tion 15 for more information.








                                                 14. MEX Compiler Reference


             14.1. Command Line Format

             The format for invoking the MEX compiler is given below:

                MEX filename [-a] [-hsize] [-s] [-q]

             filename is the name of the MEX source file to compile. If no
             file extension is specified, .mex is assumed.

             The command line switches supported by MEX are shown below in
             Table 14.1:

             Table 14.1 MEX Command Line Switches

             Parameter    Description

             -a           Display addresses instead of symbolic names
                          when writing quad output. This parameter is
                          only valid when used in conjunction with the -q
                          parameter.
             -h<size>     Set the program heap size to <size>. The heap
                          is used for storing dynamic strings. The de-
                          fault heap size is 8192 bytes, but this limit
                          may need to be increased if a large number of
                          strings are used within one MEX program.
             -s<size>     Set the program stack size to <size>. The stack
                          is used for storing local variables and for
                          performing recursive function calls. The de-
                          fault stack size is 2048 bytes, but this limit
                          may need to be increased if a program uses many
                          local variables or makes a large number of re-
                          cursive function calls.
             -q           Instead of writing out a .vm file as p-code,
                          write the output to the console as a sequence
                          of ASCII quadruples (quads). This is equivalent
                          to the "assembler output" option of most na-
                          tive-code compilers. A quad is a 4-tuple con-
                          sisting of an operator, two input arguments,
                          and a destination. The quad listing can some-
                          times be used to help debug a program.



             The MEX compiler converts the MEX program source into com-
             piled p-code which is interpreted at run-time by Maximus.
             Generating p-code has two main benefits over generating na-
             tive object code:



             14. MEX Compiler Reference                                242

             *  p-code is not operating system or processor-specific, so
                the same MEX program can run under either 16-bit DOS or 32-
                bit OS/2 environments without recompilation.

             *  Although executing p-code is somewhat slower than executing
                native object code, over 120 functions are included in the
                standard MEX run-time library that can be used to access
                internal Maximus features, perform input and output, ma-
                nipulate strings, and manage information. Since these li-
                brary functions are embedded within Maximus, they run at
                native object code speeds. The more a MEX program takes ad-
                vantage of the run-time library, the faster it runs.


             14.2. Environment Variables

             When searching for files specified in #include directives,
             the MEX compiler will first look for the include file rela-
             tive to the current directory. If the file cannot be found
             there, MEX will examine the MEX_INCLUDE environment variable.
             This variable must contain a semicolon-delimited list of
             paths where MEX include files can be found. Maximus will then
             search all of the directories listed in this environment
             variable.

             For example, by entering this at the command prompt:

                SET MEX_INCLUDE=d:\max\m;e:\mextest

             when MEX encounters an #include directive, if the file cannot
             be found in the current directory, it will look for the in-
             clude file in the d:\max\m and e:\mextest directories.


             14.3. Error Messages and Warnings

             The following error messages and warnings are generated by
             the MEX compiler:


             14.3.1. General Syntax Errors

             2000 syntax error near symbol

                  MEX could not make any sense of the source code that is
                  near the symbol token. Check your code for misplaced
                  semicolons or other common errors.

             2001 invalid identifier type

                  You attempted to use a function or structure name as a
                  variable.



             14. MEX Compiler Reference                                243

             14.3.2. Preprocessor Errors

             2100 can't open file symbol for read

                  MEX could not find the named file. Ensure that the file
                  exists and that your MEX_INCLUDE environment variable is
                  set correctly.

             2101 invalid #include directive

                  MEX could not make any sense of an include directive.
                  Ensure that a filename is specified.

             2102 invalid #include file

                  MEX could not make any sense of an include filename. En-
                  sure that the filename is surrounded by angle brackets.

             2103 too many nested include files

                  MEX can only handle up to 16 nested include files at a
                  time. Reduce the number of nested #include directives.

             2104 invalid #ifdef/#ifndef

                  The #ifdef or #ifndef statement is invalid. Ensure that
                  a proper constant or define follows the #ifdef or
                  #ifndef directive.

             2105 too many nested #ifdef/#ifndef

                  MEX only supports up to 8 nested #ifdef or #ifndef
                  statements.

             2106 unmatched #ifdef directive

                  A matching #endif could not be found for an #ifdef di-
                  rective.

             2107 unmatched #endif directive

                  A matching #ifdef could not be found for this #endif di-
                  rective.

             2108 unmatched #else directive

                  A matching #ifdef could not be found for this #else di-
                  rective.

             2109 unmatched #elifdef

                  A matching #ifdef could not be found for this #elifdef
                  directive.



             14. MEX Compiler Reference                                244

             2110 invalid #define

                  This #define directive has an incorrect format. Ensure
                  that it includes a variable to be defined.

             2111 macro symbol is already defined and is not identical

                  The symbol macro was defined using a previous #define
                  statement, but the current #define directive attempts to
                  change the value of symbol to something else.

             2112 #error directive: string

                  An #error directive was encountered in the program
                  source.

             2113 unknown directive symbol

                  An unknown preprocessor directive was encountered in the
                  source file.


             14.3.3. Lexical Errors

             2200 unterminated character constant

                  A character constant was specified, but it included a
                  newline or end-of-file instead of a character.

             2201 unterminated string constant

                  A string constant was specified, but it did not include
                  a closing double quote.

             2202 invalid character constant

                  A character constant was specified, but it did not in-
                  clude a closing single quote.

             2203 invalid hex escape sequence "\xsymbol"

                  The specified hexadecimal escape sequence is not a valid
                  hexadecimal number.

             2204 invalid character symbol

                  An invalid character was found in the source file, such
                  as an unrecognized punctuation symbol or a high-bit
                  character.



             14. MEX Compiler Reference                                245

             14.3.4. Type Mismatch Errors

             2300 type must not be `void'

                  The void type can only be used in certain locations,
                  such as in function return values and in "void ref"
                  function parameters.

             2301 symbol symbol is not a structure type

                  You attempted to use symbol as a structure tag, even
                  though no structure type definition for that tag was
                  found.

             2302 invalid type symbol for type statement

                  The argument for a if, while, for, or do .. while ex-
                  pression was not correct. Only char, int, and long can
                  be used in these expressions.

             2303 can't use function as a variable

                  You attempted to use a function name in a context that
                  required a variable name.

             2304 the type `void' cannot have a value

                  You attempted to manipulate a function returning void as
                  part of an expression.

             2305 invalid type conversion: type1 -> type2

                  It is impossible to convert an object of type1 to type2.
                  This is usually the result of incompatible types for ex-
                  plicit casts, passing parameters to functions, and pass-
                  ing back function return values.

             2306 symbol must be an array

                  You attempted to use the array operator ("[" and "]")
                  on the variable symbol which is not an array.

             2107 can't use [] on a non-array

                  An expression on the specified line cannot be used with
                  the array operator.

             2308 invalid index type for array symbol

                  The index type used to reference an array must be inte-
                  gral: either char, int, or long. The array symbol cannot
                  be indexed using any other types.



             14. MEX Compiler Reference                                246

             2309 out-of-range subscript (num) for array symbol

                  You attempted to access a subscript that was outside of
                  the bounds for the array symbol.

             2310 dot operator can only be used with structures

                  You attempted to use the dot operator (".") with a vari-
                  able that was not a structure.

             2311 symbol is not a member of struct name

                  The field symbol was not found in the structure defini-
                  tion for the structure with a tag name of name.

             2312 symbol not a goto label

                  The target of a goto must be a label, not a variable or
                  a function name.

             2313 lvalue required

                  The target of an assignment must be a simple variable or
                  the result of the array or structure operators. You can-
                  not assign a value to an expression. (For example, "i+2
                  := 2" is invalid, since "i+2" is an expression and can-
                  not be assigned a value.)

             2314 cannot apply unary minus to symbol

                  The unary minus operator cannot be applied to the symbol
                  object. The unary minus can only be applied to the char,
                  int, and long types.

             2315 declared array must have upper bound

                  An array declared in a function body must have an upper
                  bound. Only arrays declared as function parameters can
                  omit the upper bound.

             2316 cannot apply sizeof() to a boundless array

                  The sizeof operator can only be used on arrays of finite
                  dimensions.


             14.3.5. Symbol Table Errors

             2400 redeclaration of symbol

                  The variable or function symbol has already been defined
                  in this scope.



             14. MEX Compiler Reference                                247

             2401 redeclaration of structure symbol

                  The structure type symbol has already been declared in
                  this scope.

             2402 undefined structure name: symbol

                  The structure tag symbol is unknown.

             2403 symbol symbol is not a structure type

                  The tag symbol specified for a structure was the name of
                  another variable or function, rather than a proper
                  structure tag.

             2404 undefined label symbol

                  The label symbol was not found anywhere in the function
                  in which it was used.

             2405 undefined variable symbol

                  The variable symbol has not been declared.

             2406 struct symbol must be declared before use

                  Your program attempted to use a structure type that has
                  not yet been defined.

             2407 invalid redeclaration of function symbol

                  A function was declared using the same name as a global
                  variable or structure tag.

             2408 redeclaration of argument symbol

                  The function argument symbol has been declared twice in
                  the parameter list.

             2409 redeclaration of function body for symbol

                  The function body for symbol has already been encoun-
                  tered in the source file. A function can only be defined
                  once.

             2410 invalid range: `num .. num'

                  The lower bound for an array was greater than the upper
                  bound.



             14. MEX Compiler Reference                                248

             14.3.6. Function-Related Errors

             2501 argument mismatch: function=type, prototype=type

                  The type of parameter specified in the function's argu-
                  ment list differs from that specified in the function
                  prototype.

             2502 too many arguments in function declaration

                  Too many arguments were specified in the function decla-
                  ration. The function prototype specified a fewer number
                  of arguments.

             2503 too few arguments in function declaration

                  Too few arguments were specified in the function decla-
                  ration. The function prototype specifies a larger number
                  of arguments.

             2504 call to symbol with no prototype

                  A function was called, but the function was neither de-
                  fined nor prototype earlier in the source file.

             2505 variable symbol is not a function

                  You attempted to make a call to symbol, even though it
                  is a variable and not a function.

             2506 lvalue required (arg num of symbol)

                  In a call to function symbol, argument number num is
                  pass-by-reference. This means that a variable of the ap-
                  propriate type (and not an expression or constant) must
                  be passed for the specified argument.

             2507 not enough arguments in call to symbol

                  Not enough arguments were specified in the call to sym-
                  bol, relative to the function prototype.

             2508 too many arguments in call to symbol

                  Too many arguments were specified in the call to symbol,
                  relative to the function prototype.

             2509 void function cannot return a value

                  You attempted to return a value from a function that was
                  declared as returning void.



             14. MEX Compiler Reference                                249

             2510 non-void function must return a value

                  You used a simple "return;" statement with no value,
                  even though the function itself must return a value.


             14.3.7. Warnings

             3000 constant truncated: symbol

                  The numeric constant symbol was too long and had to be
                  truncated.

             3001 identifier truncated: symbol

                  The identifier symbol was too long and had to be trun-
                  cated at 32 characters.

             3002 meaningless use of an expression

                  You attempted to use the equality operator in a way that
                  does not make sense. For example, the following line of
                  code:

                     i = 2;

                  will produce this warning because you are simply compar-
                  ing the value of i to 2, but then throwing away the re-
                  sult of the comparison. You probably meant to write:

                     i := 2;

                  which assigns the value 2 to i.








                                                  15. MEX Library Reference

             This section describes all of the functions and structures
             available in the standard MEX run-time library.


             15.1. Global Variables and Data Structures

             Maximus exports certain global variables to all MEX programs.
             These variables can be used to track the internal system
             state, including information about the current message and
             file area, screen settings, user information, and more.

             All of the following global variables are declared in the
             max.mh include file. The following line must be present at
             the top of a MEX source file to access these variables:

                #include <max.mh>


             15.1.1. Strings Exported by Maximus

             This section describes the strings that are exported by Maxi-
             mus to all MEX programs.



             input




 Declaration string: input;

 Description This string contains the current "stacked keyboard input
             string" used by Maximus. The input string contains a sequence
             of keys that will be used to try to satisfy the input re-
             quirements of following calls to the input_ch, input_str, and
             input_list functions. The internal Maximus input commands
             also use this buffer for their own input.

             The internal Maximus input functions also try to take their
             input from this string before prompting the user for input.

             The input_* functions will draw as many characters as neces-
             sary from this string to satisfy an input request. (In the
             case of input_ch or input_list, only a single character will
             normally be removed. In the case of input_str, a single word
             or an entire line is normally removed.)



             15. MEX Library Reference                                 252

             This string can be modified by MEX programs.


             15.1.2. Structures Exported by Maximus

             This section describes the structures that are exported by
             Maximus to all MEX programs:



             struct _instancedata




 Declaration struct _instancedata: id;

 Description This structure contains information about the current Maximus
             session. The contents of the structure are shown below in
             Table 15.1:

             Table 15.1 struct _instancedata

              Field          Type      Description

              instant_video  int       This controls the "instant video"
                                       setting. If instant video is en-
                                       abled, output displayed by print
                                       will be shown on the local screen
                                       as soon as the print function is
                                       called.
                                       However, screen updating can be a
                                       slow process, so it is sometimes
                                       more efficient to disable local
                                       screen writes, perform many print
                                       calls, and to then display the lo-
                                       cal screen again (using the vid-
                                       sync function) after all of the
                                       print calls have been completed.
                                       To disable the instant screen up-
                                       dating feature, set
                                       id.instant_video to 0. While this
                                       variable is set to 0, the print
                                       function will not cause the local
                                       screen to be updated.
                                       However, be warned that some in-
                                       ternal Maximus functions will up-
                                       date the screen regardless of this
                                       setting. Examples of this are in-
                                       put_ch, input_str and input_list.
                                       This field can be modified by MEX
                                       programs.
              task_num       unsigned  The current task number.



             15. MEX Library Reference                                 253

                             int
              local          int       TRUE if the caller is logged on at
                                       the local console.
               port          int       Under DOS: the current COM port
                                       number.
                                       Under OS/2: the current communica-
                                       tions handle.
              speed          unsigned  The user's connection speed, in
                             long      bits per second (bps).
              alias_system   int       TRUE if the system supports ali-
                                       ases ("Alias System" in the system
                                       control file).
              ask_name       int       TRUE if the system will ask the
                                       user for a real name.
              use_umsgid     int       TRUE if the system displays UMS-
                                       GIDs instead of message numbers.



             struct _marea




 Declaration struct _marea: marea;

 Description This structure contains information about the current message
             area. Structures of this type are also returned by the msga-
             reafind* functions. The contents of the structure are shown
             below in Table 15.2:

             Table 15.2 struct _marea

              Field         Type      Description

              name          string    This name of the message area.
              descript      string    The description for the message
                                      area.
              path          string    The path and/or filename of the
                                      message area. (*.MSG areas will be
                                      provided as a path; Squish areas
                                      will be provided as a path and
                                      filename.)
              tag           string    The tag for this area (for use in
                                      EchoMail applications).
              attachpath    string    The path for local file attaches.
              barricade     string    The barricade filename for this
                                      area.
              division      int       Non-zero if this is a message di-
                                      vision starting or ending record.
                                      (1=beginning; 2=ending.)
              type          int       Message area type. One of either
                                      MSGTYPE_SQUISH or MSGTYPE_SDM



             15. MEX Library Reference                                 254

                                      (*.MSG).
              attribs       int       Message area attributes. See the
                                      MA_* definitions in max.mh.



             struct _farea




 Declaration struct _farea: farea;

 Description This structure contains information about the current file
             area. Structures of this type are also returned by the
             fileareafind* functions. The contents of this structure are
             shown in Table 15.3:

             Table 15.3 struct _farea

              Field      Type     Description

              name       string   This name of the file area.
              descript   string   The description for the file area.
              downpath   string   The download path for this file
                                  area.
              uppath     string   The upload path for this file area.
              filesbbs   string   Path to the files.bbs-like list for
                                  this file area.
              barricade  string   The barricade filename for this
                                  area.
              division   int      Non-zero if this is a file division
                                  starting or ending record.
                                  (1=beginning; 2=ending.)
              attribs    int      File area attributes. See the FA_*
                                  definitions in max.mh.



             struct _msg




 Declaration struct _msg: msg;

 Description This structure contains the current message number and other
             related information. The contents of the structure are shown
             below in Table 15.4:



             15. MEX Library Reference                                 255

             Table 15.4 struct _msg

              Field       Type     Description

              current     long     The current message number, or if Use
                                   UMSGIDs is enabled, the UMSGID of the
                                   current message number. This field
                                   can be modified by MEX programs.
              high        long     The highest message number in the
                                   current area, or if Use UMSGIDs is
                                   enabled, the UMSGID of the highest
                                   message number.
              num         long     The number of messages in the current
                                   area.
              direction   int      Message reading direction. 1 = next;
                                   0 = prior.



             struct _usr




 Declaration struct _usr: usr;

 Description This structure contains information about the current user.
             Structures of this type are also manipulated by the user*
             functions.

             Table 15.5 describes the contents of this structure. All
             fields in this structure can be modified by MEX programs.

             Table 15.5 struct _usr

              Field            Type       Description

              name             string     The user's name.
              city             string     The user's city and
                                          state/province.
              alias            string     The user's alias.
              phone            string     The user's voice telephone
                                          number
              lastread_ptr     unsigned   An integer that is unique
                               int        among all users in the sys-
                                          tem. This number is used as
                                          an index for the lastread
                                          pointers in the Squish SQI
                                          files, to find records in the
                                          \max\olr\dats directory, and
                                          in numerous other places.
              pwd              string     The user's password. If the
                                          "usr.encrypted" flag is set,



             15. MEX Library Reference                                 256

                                          this may not be a readable
                                          password.
              times            unsigned   The number of previous calls
                               int        to the system made by this
                                          user.
              help             char       The user's help level.
                                          (Novice = 6; Regular = 4; Ex-
                                          pert = 2.)
              video            char       The user's video mode. (0 =
                                          TTY; 1 = ANSI; 2 = AVATAR.)
              nulls            char       The number of NUL characters
                                          sent after a carriage return.
              hotkeys          char       TRUE if hotkeys are enabled.
              notavail         char       TRUE if the user is not
                                          available for multinode chat-
                                          ting.
              fsr              char       TRUE if the user has enabled
                                          the full-screen reader.
              nerd             char       TRUE if the user is a nerd
                                          (meaning that the user's
                                          yells are silenced).
              noulist          char       TRUE if the user does not
                                          show up in the userlist.
              tabs             char       TRUE if the user's terminal
                                          can handle tab characters.
              encrypted        char       TRUE if the user's password
                                          is encrypted.
              rip              char       TRUE if the user has enabled
                                          RIPscrip graphics.
              badlogon         char       TRUE if the user's last log-
                                          on attempt resulted in a
                                          failed password.
              ibmchars         char       TRUE if the user has enabled
                                          the high-bit IBM character
                                          set.
              bored            char       TRUE if the line editor is
                                          enabled; otherwise, the full-
                                          screen MaxEd is used.
              more             char       TRUE if the "More" prompt is
                                          enabled.
              configured       char       TRUE if the user's city and
                                          password fields have been
                                          set.
              cls              char       TRUE if the user's terminal
                                          can handle screen clears.
              priv             unsigned   The user's privilege level.
                               int
              dataphone        string     The user's data phone number.
              time             unsigned   The length of time (in min-
                               int        utes) that the user has been
                                          on-line today.
              deleted          char       TRUE if the user has been de-
                                          leted.



             15. MEX Library Reference                                 257

              permanent        char       TRUE if the user is undelet-
                                          able.
              msgs_posted      long       The total number of messages
                                          posted by this user.
              msgs_read        long       The total number of messages
                                          read by this user.
              width            char       The width of the caller's
                                          screen. Also see the
                                          term_width and screen_width
                                          functions in the run-time li-
                                          brary reference.
              len              char       The height of the caller's
                                          screen. Also see the
                                          term_length and screen_length
                                          functions in the run-time li-
                                          brary reference.
              credit           unsigned   User's NetMail credit, in
                               int        cents.
              debit            unsigned   User's NetMail debit, in
                               int        cents.
              xp_priv          unsigned   Priv level to which the user
                               int        will be demoted when the cur-
                                          rent subscription expires.
              xp_date          struct     Date and time for the user's
                               _stamp     subscription expiry.
              xp_mins          unsigned   Number of minutes remaining
                               long       in the user's subscription.
              expdate          char       TRUE if the user expires
                                          based on the xp_date field.
              expmins          char       TRUE if the user expires
                                          based on the xp_mins field.
              expdemote        char       TRUE if the user is to be de-
                                          moted to the value in the
                                          xp_priv field when the sub-
                                          scription expires.
              expaxe           char       TRUE if Maximus should hang
                                          up on the caller when the
                                          subscription expires.
              sex              char       The user's gender: either
                                          SEX_MALE, SEX_FEMALE or
                                          SEX_UNKNOWN.
              ludate           struct     Date of the user's last call.
                               _stamp
              xkeys            string     The user's keys (as a
                                          string).
              lang             char       The user's current language
                                          number. The lan-
                                          guage_num_to_string function
                                          is to translate this number
                                          into a string.
              def_proto        char       The user's default protocol.
                                          This can be one of the PROTO-
                                          COL_* defines from max.mh, or



             15. MEX Library Reference                                 258

                                          it can be a positive index to
                                          indicate an external proto-
                                          col. The proto-
                                          col_num_to_string function is
                                          used to translate all of
                                          these numbers (for both in-
                                          ternal and external proto-
                                          cols) into strings.
              up               unsigned   Total kilobytes uploaded for
                               long       all calls.
              down             unsigned   Total kilobytes downloaded
                               long       for all calls.
              downtoday        unsigned   Total kilobytes downloaded
                               long       today.
              msg              string     The user's current message
                                          area.
              files            string     The user's current file area.
              compress         char       The user's default compres-
                                          sion program. The compres-
                                          sor_num_to_string function is
                                          used to translate this number
                                          into a string.
              dob              string     The caller's date of birth
                                          (in "yyyy.mm.dd" format).
              date_1stcall     struct     Date/time of the user's first
                               _stamp     call to the system.
              date_pwd_chg     struct     Date/time of the user's most
                               _stamp     recent password change.
              nup              unsigned   Total number of files up-
                               long       loaded to the system.
              ndown            unsigned   Total number of files down-
                               long       loaded from the system.
              ndowntoday       unsigned   Number of files downloaded
                               long       from the system today.
              time_added       unsigned   Credits added to the user's
                               int        time today (for chatting with
                                          the SysOp or for upload time
                                          credits).
              point_credit     unsigned   Total number of point cred-
                               long       its.
              point_debit      unsigned   Total number of point debits.
                               long
              date_newfile     struct     Date/time of last "new files"
                               _stamp     search.
              call             unsigned   Number of previous calls to-
                               int        day.



             15. MEX Library Reference                                 259


             struct _sys




 Declaration struct _sys: sys;

 Description This structure contains information about the current system
             screen display. The contents of this structure are described
             in Table 15.6:

             Table 15.6 struct _sys

              Field        Type  Description

              current_row  int   The current cursor row position.
              current_col  int   The current cursor column position.
              more_lines   int   The number of lines displayed since the
                                 last "More [Y,n,=]" prompt.


             15.1.3. Other Data Structures

             The structures listed in this section are not exported di-
             rectly by Maximus. However, the structures are used (directly
             or indirectly) by some of the functions in the run-time li-
             brary. Please consult section 15.3 for more information on
             the structures used by a particular function.



             struct _date




 Description This structure is used in various places to represent a sys-
             tem date. The contents of the structure are described in
             Table 15.7:

             Table 15.7 struct _date

              Field   Type   Description

              day     char   The day of the month. (1 = the first day.)
              month   char   The  month of the year. (1 = January.)
              year    char   The current year less 1980. (0 = 1980.)



             15. MEX Library Reference                                 260


             struct _time




 Description This function is used in various places to represent a system
             time. The contents of this structure are described in Table
             15.8:

             Table 15.8 struct _time

              Field  Type   Description

              hh     char   Hour in 24-hour format. (0 = midnight; 12 =
                            noon, 17 = 5 P.M.)
              mm     char   Minute. (Must be within 0 - 59 inclusive.)
              ss     char   Second. (Must be within 0 - 59 inclusive.)





             struct _stamp




 Description This structure contains copies of both a date and time struc-
             ture to provide a complete system timestamp. The contents of
             this structure are described in Table 15.9:

             Table 15.9 struct _stamp

              Field  Type              Description

              date   struct _date      A copy of the date structure.
              time   struct _time      A copy of the time structure.





             struct _cstat




 Description This structure is used by the chat_querystatus function. The
             contents of this structure are described in Table 15.10:



             15. MEX Library Reference                                 261

             Table 15.10 struct _cstat

              Field       Type     Description

              task_num    int      The user's task number
              avail       int      TRUE if the user is available for chat
              username    string   The user's name
              status      string   A status message describing the user's
                                   current actions.



             struct _ffind




 Description This structure is used by the filefind* functions to retrieve
             file status information. The contents of this structure are
             described in Table 15.11:

             Table 15.11 struct _ffind

              Field     Type             Description

              finddata  long             Instance-specific find data. This
                                         information is internal to Maxi-
                                         mus and must not be modified by
                                         the MEX program.
              filename  string           The name of the file.
              filesize  unsigned long    The size of the file.
              filedate  struct _stamp    The file's modification
                                         date/time.
              fileattr  unsigned int     The file's attributes. See the
                                         FA_* definitions in max.mh.



             struct _callinfo




 Description This function is used by the call* functions to read records
             from the caller log file. The contents of this structure are
             described in Table 15.12:

             Table 15.12 struct _callinfo

              Field         Type       Description

              name          string     The user's name.
              city          string     The user's city.



             15. MEX Library Reference                                 262

              login         struct     The user's log-on time.
                            _stamp
              logoff        struct     The user's log-off time.
                            _stamp
              task          int        The Maximus task number that cre-
                                       ated this record.
              flags         int        A combination of the CALL_* defi-
                                       nitions from max.mh.
              logon_priv    unsigned   The user's privilege level at
                            int        log-on.
              logon_xkeys   string     The user's key settings at log-
                                       on.
              logoff_priv   unsigned   The user's privilege level at
                            int        log-off.
              logoff_xkeys  string     The user's key settings at log-
                                       off.
              filesup       unsigned   Number of files uploaded in this
                            int        session.
              filedn        unsigned   Number of files downloaded in
                            int        this session.
              kbup          unsigned   Number of kilobytes uploaded in
                            int        this session.
              kbdn          unsigned   Number of kilobytes downloaded in
                            int        this session.
              calls         unsigned   Number of calls user made to the
                            int        system (as of when the record was
                                       written).
              read          unsigned   Number of messages read during
                            int        the session.
              posted        unsigned   Number of messages posted during
                            int        the session.
              paged         unsigned   Number of times that the SysOp
                            int        was paged during the session.
              added         int        Number of minutes that were cred-
                                       ited to the user's time for the
                                       day due to file uploads or chat-
                                       ting with the SysOp.


             15.2. Functions by Category

             This section gives a categorized listing of functions in the
             MEX run-time library. The functions are first listed by cate-
             gory; however, the next section gives a detailed description
             of each function, including the function prototype, argu-
             ments, return value, and overall function behavior.


             15.2.1. Screen Output and Display Formatting

             The functions listed in Table 15.13 are used for printing
             text, displaying output, and getting/setting screen format-
             ting information.



             15. MEX Library Reference                                 263

             Table 15.13 Screen Output and Display Formatting Functions

              Function       Description

              do_more        Optionally displays a "More [Y,n]" prompt.
              issnoop        Determines if "Snoop Mode" is active.
              print          Sends text to the user.
              reset_more     Resets the counter for a "More" prompt.
              screen_length  Returns the length of the system console.
              screen_width   Returns the width of the system console.
              set_output     Enables or disables local/remote output.
              set_textsize   Sets the size of the text window (for
                             RIPscrip graphics).
              snoop          Enables or disables "Snoop Mode."
              term_length    Returns the length of the user's virtual
                             terminal.
              term_width     Returns the width of the user's virtual
                             terminal.
              vidsync        Updates the local video screen after a
                             call to print.


             15.2.2. Keyboard Input

             The functions listed in Table 15.14 are used for getting in-
             put from the user and for processing keystrokes.

             Table 15.14 Keyboard Input Functions

              Function      Description

              getch         Returns the next raw keystroke entered by
                            the user.
              input_ch      Gets a character from the user (with format-
                            ting).
              input_list    Gets a character from the user (from a list
                            of choices).
              input_str     Gets an entire word or string from the user.
              iskeyboard    Determines if local keyboard mode is en-
                            abled.
              kbhit         Checks to see if the user has pressed a key.
              keyboard      Enables/disables local keyboard mode.
              localkey      Determines if the last keystroke was entered
                            by a remote user.


             15.2.3. External Programs, .BBS files, and Menu Options

             The functions listed in Table 15.15 are used to interface to
             non-MEX scripts or programs, such as .bbs files, Maximus menu
             commands, and external programs.



             15. MEX Library Reference                                 264

             Table 15.15 External Program Functions

              Function       Description

              display_file   Displays a .BBS, .GBS or .RBS file.
              menu_cmd       Runs most internal Maximus menu commands.
              shell          Shells to an external program (.exe, .bat,
                             .cmd, etc.)



             15.2.4. File I/O and Disk Operations

             The functions listed in Table 15.16 support opening, reading,
             writing, and performing other types of file manipulation and
             information-gathering.

             Table 15.16 File and Disk Operations

              Function    Description

              close       Closes a file handle.
              filecopy    Copies a file from one location to another.
              filedate    Retrieves the date for a file.
              fileexists  Determines if a file exists.
              filesize    Returns the size of a file.
              open        Opens a file for read or write.
              read        Reads a block from a file.
              readln      Reads an entire line from a file.
              remove      Deletes a file.
              rename      Renames a file.
              seek        Sets a file's "next read/write location"
                          pointer.
              tell        Returns a file's "next read/write location"
                          pointer.
              write       Write a block to a file.
              writeln     Write an entire line to a file.



             15.2.5. File Searching Operations

             The functions listed in Table 15.17 are used to expand file-
             name wildcards and/or perform file directory searches.

             Table 15.17 File Searching Operations

              Format          Description

              filefindclose   Terminates a file-find search.
              filefindfirst   Starts looking for a named file (or a
                              wildcard).



             15. MEX Library Reference                                 265

              filefindnext    Find the next file after starting a
                              search.



             15.2.6. Strings

             The functions listed in Table 15.18 are used for common
             string manipulation operations, such as padding, stripping,
             finding substrings, and more.

             Table 15.18 String Operations

              Function     Description

              strfind      Finds the index of a substring within another
                           string.
              stridx       Finds the index of a character within a
                           string.
              strlen       Returns the length of a string.
              strlower     Converts a string to lowercase.
              strpad       Right-pads a string with a certain character.
              strpadleft   Left-pads a string with a certain character.
              strridx      Returns the index of the rightmost character
                           within a string that contains a specific
                           value.
              strtok       Tokenizes a string.
              strupper     Converts a string to uppercase.
              strtrim      Remove unwanted characters on either end of a
                           string.
              substr       Extracts a substring from another, given the
                           substring's size and location.



             15.2.7. Time and Date

             The functions listed in Table 15.19 are used to check the
             current system time, in addition to setting and querying in-
             formation about the user's current time limit.

             Table 15.19 Time and Date Functions

              Function         Description

              long_to_stamp    Converts a long-format timestamp into a
                               string.
              stamp_string     Converts a stamp structure into a string.
              stamp_to_long    Converts a stamp structure into a long.
              time             Returns the current time as a long.
              time_check       Check the user's current time limit.
              timeadjust       Adjust a user's time limit.
              timeadjustsoft   Adjust a user's time limit without over-



             15. MEX Library Reference                                 266

                               running events.
              timeleft         Returns the length of time remaining in
                               this session.
              timeon           Returns the amount of time that the user
                               has been on-line.
              timestamp        Returns the current time as a stamp
                               structure.
              xfertime         Calculates the approximate time required
                               for a file transfer.


             15.2.8. Time Delay

             The function listed in Table 15.20 is used for pausing pro-
             gram operation.

             Table 15.20 Time Delay Functions

              Function   Description

              sleep      Causes the system to delay for a certain period
                         of time.


             15.2.9. Type Conversions

             The functions listed in Table 15.21 are used to convert data
             between the string type and one of the integral types.

             Table 15.21 Type Conversion Functions

              Function      Description

              itostr        Converts an integer to a string.
              ltostr        Converts a long to a string.
              strtoi        Converts a string to an integer.
              strtol        Converts a string to a long.
              uitostr       Converts an unsigned integer to a string.
              ultostr       Converts an unsigned long to a string.


             15.2.10. Modem and Communications

             The functions listed in Table 15.22 are used to directly con-
             trol the modem.

             Table 15.22 Modem and Communications Functions

              Function      Description

              carrier       Checks whether or not DCD is present.
              dcd_check     Enables or disables automatic DCD checking.
              mdm_command   Sends a command to the modem.



             15. MEX Library Reference                                 267

              mdm_flow      Enables or disables flow control.


             15.2.11. Message Areas

             The functions listed in Table 15.23 are used to select the
             current message area and to search the message area data
             file.

             Table 15.23 Message Area Functions

              Function           Description

              msg_area           Displays the message-area menu.
              msgareafindclose   Terminates a message-area finding ses-
                                 sion.
              msgareafindfirst   Starts a message-area finding session.
              msgareafindnext    Finds the next area in a message-area
                                 finding session.
              msgareafindprev    Finds the previous area in a message-
                                 area finding session.
              msgareaselect      Sets the user's current message area.


             15.2.12. File Areas

             The functions listed in Table 15.24 are used to select the
             current file area and to search the file area data file.

             Table 15.24 File Area Functions

              Function            Description

              file_area           Displays the file-area menu.
              fileareafindclose   Terminates a file-area finding ses-
                                  sion.
              fileareafindfirst   Starts a file-area finding session.
              fileareafindnext    Finds the next area in a file-area
                                  finding session.
              fileareafindprev    Finds the previous area in a file-
                                  area finding session.
              fileareaselect      Sets the user's current file area.


             15.2.13. File Tag Queue

             The functions listed in Table 15.25 are used to manipulate
             the queue of files to be downloaded.

             Table 15.25 File Tag Queue Functions

              Function            Description



             15. MEX Library Reference                                 268

              tag_dequeue_file    Removes a file from the tag queue.
              tag_get_name        Retrieves information about a file in
                                  the queue.
              tag_queue_file      Inserts a file in the queue.
              tag_queue_size      Returns the number of files in the
                                  queue.


             15.2.14. User File

             The functions listed in Table 15.26 are used to expand
             strings in user records, modify records in the user file, and
             to search the user file for selected records.

             Table 15.26 User File Functions

              Function                Description

              compressor_num_to_name  Converts the "usr.compress" field
                                      to a string.
              language_num_to_name    Converts the "usr.lang" field to a
                                      string.
              protocol_num_to_name    Converts the "usr.def_proto" field
                                      to a string.
              usercreate              Creates a new user record.
              userfilesize            Returns the size of the user file.
              userremove              Deletes a user record.
              userupdate              Updates an existing user record.
              userfindclose           Terminates a user-file finding
                                      session.
              userfindnext            Finds the next user record in a
                                      user-file finding session.
              userfindopen            Starts a user-file finding ses-
                                      sion.
              userfindprev            Finds the previous user record in
                                      a user-file finding session.
              userfindseek            Seeks to a specific user in a
                                      user-file finding session.


             15.2.15. Caller File Manipulation

             The functions listed in Table 15.27 are used to read the con-
             tents of the caller log file.

             Table 15.27 Caller File Functions

              Function        Description

              call_close      Closes the caller log file.
              call_numrecs    Returns the number of records in the
                              caller log file.
              call_open       Opens the caller log file.



             15. MEX Library Reference                                 269

              call_read       Reads from the caller log file.


             15.2.16. Log File

             The functions listed in Table 15.28 are used to append to the
             system log file.

             Table 15.28 Log File Functions

              Function   Description

              log        Adds a line to the system log.


             15.2.17. Maximus Control File Information

             The functions listed in Table 15.29 read from the Maximus
             .PRM file.

             Table 15.29 Control File Functions

              Function    Description

              prm_string  Returns a string from the MAX.PRM file.


             15.2.18. Privilege Level Information

             The functions listed in Table 15.30 return information about
             user classes (from the class definition file).

             Table 15.30 Privilege Level Functions

              Function            Description

              class_abbrev        Returns the abbreviation for a user
                                  class.
              class_info          Returns information about a user
                                  class.
              class_loginfile     Returns the login filename for a user
                                  class.
              class_name          Returns the name for a user class.
              class_to_priv       Converts a user class to a privilege
                                  level.
              privok              Checks if the user's access level sat-
                                  isfies a given ACS.


             15.2.19. Chat and Multinode Chat

             The functions listed in Table 15.31 provide a very limited
             interface to the system and multinode chat facilities.



             15. MEX Library Reference                                 270

             Table 15.31 Chat Functions

              Function           Description

              chat_querystatus   Query the multinode chat status of a
                                 user.
              chatstart          Enable local chat mode.


             15.2.20. Multilingual Support

             The functions listed in Table 15.32 allow strings to be re-
             trieved from the language file.

             Table 15.32 Multilingual Functions

              Function   Description

              hstr       Extract a string from a user language heap.
              lstr       Extract a string from the system language file.


             15.2.21. Static data

             The functions listed in Table 15.33 allow data to be created
             that stays "alive" for an entire Maximus session.

             Table 15.33 Static Data Functions

              Function               Description

              create_static_data     Creates a static data object.
              create_static_string   Creates a static string.
              destroy_static_data    Destroys a static data object.
              destroy_static_string  Destroys a static string.
              get_static_data        Gets information from a static data
                                     object.
              get_static_string      Gets information from a static
                                     string.
              set_static_data        Stores information in a static data
                                     object.
              set_static_string      Stores information in a static
                                     string.


             15.2.22. ANSI and RIPscrip Support

             The functions listed in Table 15.34 are used to query ANSI
             and RIPscrip support and to perform RIPscrip-specific file
             functions. (For information on sending ANSI or AVATAR cursor
             control codes to the user, instead see section 13.5.)



             15. MEX Library Reference                                 271

             Table 15.34 ANSI and RIPscrip Functions

              Function      Description

              ansi_detect   Determines if the user's terminal supports
                            ANSI.
              rip_detect    Determines if the user's terminal supports
                            RIPscrip.
              rip_hasfile   Determines if the user already has a spe-
                            cific RIPscrip scene or icon file.
              rip_send      Sends a RIPscrip file to the user.



             15. MEX Library Reference                                 272


             15.3. Function Descriptions

             This section contains detailed descriptions of all of the
             functions contained in the MEX run-time library.

             As a reminder, do not forget to include the following line at
             the beginning of any MEX source file that accesses the li-
             brary routines given in this section:

                #include <max.mh>


             ansi_detect




 Prototype   int ansi_detect();

 Arguments   None

 Return Val. TRUE if the user's terminal supports ANSI; FALSE otherwise.

 Description The ansi_detect function is used to query the remote terminal
             to determine if it supports ANSI graphics. If the remote ter-
             minal reports that ANSI graphics are supported, this function
             returns TRUE.

             Note that some terminal programs may not support the control
             sequence used to query ANSI support. This means that this
             function may sometimes return FALSE, even if the user's ter-
             minal program does support ANSI. However, a return value of
             TRUE always indicates that the user's terminal supports ANSI.

             After the user has logged on, the user's ANSI graphics pref-
             erence can be read from the usr.video field.



             call_close




 Prototype   void call_close();

 Arguments   None

 Return Val. None

 Description This function releases the resources that were allocated to a
             MEX program by the call_open function. call_close should al-



             15. MEX Library Reference                                 273

             ways be called when the application is finished using the
             caller log.



             call_numrecs




 Prototype   long call_numrecs();

 Arguments   None

 Return Val. If the file was successful accessed, the number of records
             contained in the caller log;
             0 otherwise.

 Description The call_numrecs function enumerates the records in the
             caller log file. The call_read function can be used to read
             any of the records in the caller file, up to and including
             the record number returned by this function.



             call_open




 Prototype   int call_open();

 Arguments   None

 Return Val. TRUE if the caller file was opened successfully; FALSE other-
             wise.

 Description call_open is used to access the caller log, as defined by the
             File Callers keyword in the system control file.

             The caller log is different from the system log file, al-
             though both files contain similar information. While the sys-
             tem log file contains an ASCII listing of system events,
             meant to be read by humans, the caller log contains binary
             information that can be read by MEX programs and third-party
             utilities.

             The call_open function is used to obtain access to the caller
             log. After call_open has been called, any of the other call_*
             functions can be used to retrieve information from the caller
             log.



             15. MEX Library Reference                                 274


             call_read




 Prototype   int call_read(long: recno, ref struct _callinfo: ci);

 Arguments   recno The record number to be read from the caller log file.
             A value of 0 specifies the first record in the file. The
             range of valid record numbers can be determined by calling
             call_numrecs. In general, the range is from 0 to
             call_numrecs()-1 (inclusive).

             ci    The _callinfo structure into which the found record is
             to be placed.

 Return Val. TRUE if the record was successfully read; FALSE otherwise

 Description This function reads a record from the caller log file. The
             record specified by the recno parameter will be read from the
             caller log and placed into the structure referenced by the ci
             parameter.

             The _callinfo structure is defined in max.mh. A description
             of the fields in the structure can be found in the previous
             section.

 Example     A typical sequence of calls for accessing the caller file
             (without error-checking) is:

                #include <max.mh>

                int main()
                {
                  struct _callinfo: ci;
                  long: num_recs;
                  int: i;

                  call_open();
                  num_recs := call_numrecs();

                  for (i := 0; i < num_recs; i := i+1)
                  {
                       call_read(i, ci);
                       // Process information in the "ci" structure
                  }

                  return 0;
                }



             15. MEX Library Reference                                 275


             carrier




 Prototype   int carrier();

 Arguments   None

 Return Val. TRUE if DCD is present (high); FALSE if DCD is not present
             (low). This function always returns TRUE for local sessions.

 Description This function is used to sample the status of the modem DCD
             line. DCD is present if a caller is currently on-line.

             In most cases, DCD will always be present, since Maximus will
             normally recycle if a caller hangs up. However, if the auto-
             matic carrier-checking feature has been disabled with
             dcd_check, the carrier function can be used to manually check
             the status of the DCD line.



             chat_querystatus




 Prototype   int chat_querystatus(ref struct _cstat: cs);

 Arguments   cs    A reference to a caller status structure. On input, the
             cs.task_num field contains the task number whose status is to
             be queried. On output, the rest of the fields in the struc-
             ture will be updated to describe the status of the requested
             task.

 Return Val. TRUE if the status information was successfully read; FALSE
             if the task was not on-line, an invalid task number was
             specified, or if Maximus could not communicate with the chat
             server.

 Description This function is used to retrieve the status of an on-line
             user, including the user's name, status, and chat availabil-
             ity flag.

             Before calling chat_querystatus, the cs.task_num field should
             be filled out with the task number of the task to be queried.

             After the call, the cs structure will be filled out with all
             of the information about the requested task number.



             15. MEX Library Reference                                 276


             chatstart




 Prototype   void chatstart();

 Arguments   None

 Return Val. None

 Description The chatstart function is used to inform Maximus that the
             user is entering "chat" mode. This function is typically only
             used for MEX-based chat programs.

             When chat mode is in effect, the user's time limit is not
             decremented, and the "chat requested" flag on the status line
             is reset.



             class_abbrev




 Prototype   string class_abbrev(int: priv);

 Arguments   priv  The privilege level to be queried. This number can be
             in the range 0 through 65535.

 Return Val. A string indicating the name of the user class associated
             with the specified privilege level.

 Description This function is used to display a textual representation of
             a privilege level, rather than the numeric value of the
             privilege level itself. This function uses the information
             provided in the access control file to translate numeric
             privilege levels into strings.

 Example     If the standard privilege levels have not been modified, the
             following code will display "SysOp."  (100 is the privilege
             level of the SysOp class, as defined in the standard access
             control file.)

                #include <max.mh>

                int main()
                {
                  string: s;

                  s := class_abbrev(100);



             15. MEX Library Reference                                 277

                  print(s);

                  return 0;
                }


             class_info




 Prototype   long class_info(int: priv, int: cit);

 Arguments   priv  Privilege level which is to be queried.

             cit   One of the CIT_* constants describing the type of query
             to perform.

 Return Val. This function returns the requested value from the class in-
             formation structure, or -1 if an invalid value was specified
             for cit.

 Description This function is used to query a given privilege level for
             various types of information, such as its default time lim-
             its, download limits, and other miscellaneous values.

             Maximus first searches the definitions in the access control
             file to find the privilege class which is closest to (but
             which does not exceed) the privilege level specified by priv.
             It then returns the information requested by the cit parame-
             ter.

             The cit parameter can be any of the constants described in
             Table 15.35 below:

             Table 15.35 Class Information Types

              cit                  Description

              CIT_NUMCLASSES       If this value is specified, the priv
                                   parameter is ignored, and class_info
                                   returns the number of privilege level
                                   classes that are defined in the ac-
                                   cess control file.
              CIT_DAY_TIME         The maximum daily time limit.
              CIT_CALL_TIME        The maximum per-connection time
                                   limit.
              CIT_DL_LIMIT         The daily download limit, in kilo-
                                   bytes.
              CIT_RATIO            The maximum download : upload ratio.
              CIT_MIN_BAUD         The minimum speed required to log on.
              CIT_MIN_XFER_BAUD    The minimum speed required to down-
                                   load or upload files.



             15. MEX Library Reference                                 278

              CIT_MAX_CALLS        The maximum number of times that a
                                   user can call in a given day.
              CIT_FREE_RATIO       The number of kilobytes that can be
                                   downloaded before the download ratio
                                   takes effect.
              CIT_UPLOAD_REWARD    Percentage of the user's time re-
                                   warded for uploading files.
              CIT_ACCESSFLAGS      User access flags, as defined in the
                                   access control file. See the CFLAGA_*
                                   definitions in max.mh for more infor-
                                   mation.
              CIT_MAILFLAGS        User mail capability flags, as de-
                                   fined in the access control file. See
                                   the CFLAGM_* definitions in max.mh
                                   for more information.
              CIT_USERFLAGS        User-specific flags, which were spe-
                                   cifically designed for use by MEX
                                   programs. See the documentation for
                                   these flags in the access control
                                   file for more information.
              CIT_LEVEL            The numeric privilege level associ-
                                   ated with this class. Since Maximus
                                   retrieves the class with the privi-
                                   lege level closest to (but not ex-
                                   ceeding) the priv parameter, the
                                   value returned by this function will
                                   not necessarily be the same as the
                                   value provided for priv.
              CIT_CLASSKEY         The "key" associated with the class.
                                   This is normally the first letter of
                                   the class abbreviation, but it can be
                                   changed manually by the SysOp.
              CIT_INDEX            The "index number" of the specified
                                   privilege level.
              CIT_OLDPRIV          The old-style Maximus 2.x privilege
                                   level that corresponds to priv. This
                                   can be used when writing programs to
                                   manipulate data structures that are
                                   used by external programs designed to
                                   work with Maximus 2.x.
              CIT_BYINDEX          If this value is combined with any of
                                   the CIT_ parameters above (using the
                                   bitwise or operator), the value of
                                   priv is assumed to be a class index
                                   rather than a privilege level.


             This code displays the maximum daily time limit for the cur-
             rent user:

                #include <max.mh>

                int main()



             15. MEX Library Reference                                 279

                {
                  long: lim;

                  lim := class_info(usr.priv, CIT_DAY_TIME);
                  print("Maximum daily limit: ", lim, " minutes.\n");

                  return 0;
                }

             The following code can be used to iterate through all of the
             class definitions in the access control file:

                #include <max.mh>

                int main()
                {
                  int: i, n;
                  unsigned int: priv;

                  n := class_info(0, CIT_NUMCLASSES);

                  for (i := 0; i < n; i := i+1)
                  {
                       priv := class_info(i,
                                          CIT_LEVEL | CIT_BYINDEX);
                       print("Priv for class ", i, " is ",
                             priv, '\n');
                  }

                  return 0;
                }


             class_loginfile




 Prototype   string class_loginfile(int: priv);

 Arguments   priv  The privilege level to be queried

 Return Val. A string representing the log-in file specific to callers in
             this privilege level. The null string ("") is returned if no
             log-in file is defined for the requested privilege level.

 Description This function is used to retrieve the name of the custom log-
             in file for members of a specific privilege level. The custom
             log-in file is typically used to display information that
             only pertains to a specific group of users.



             15. MEX Library Reference                                 280

             While Maximus will normally display this file automatically
             at log-on, MEX programs can also use this information to dis-
             play the file manually.

 Example     This code will display the custom log-on file for the current
             user:

                #include <max.mh>

                int main()
                {
                  string: file;
                  char: nonstop;

                  file := class_loginfile(usr.priv);
                  nonstop := 0;

                  if (file <> "")
                       display_file(file, nonstop);

                  return 0;
                }


             class_name




 Prototype   string class_name(int: priv);

 Arguments   priv  The privilege level to be queried

 Return Val. A string containing the name of the privilege level.

 Description This function is used to obtain the description for a spe-
             cific privilege level from the access control file.



             class_to_priv




 Prototype   unsigned int class_to_priv(string: classabbrev);

 Arguments   classabbrev    A string containing an abbreviation for a
             class privilege level.

 Return Val. The numeric privilege level associated with the name, or
             65535 if the name could not be matched to any existing class.



             15. MEX Library Reference                                 281

 Description This function is used to translate text-based privilege level
             names into numeric privilege level values, such as those
             stored in many of the internal Maximus structures.



             close




 Prototype   int close(int fd)

 Arguments   fd     A file handle previously returned by open.

 Return Val. TRUE if the file was successfully closed; FALSE otherwise.

 Description This function is used to close a file handle that was previ-
             ously opened by open. MEX programs should close file handles
             as soon as all file operations on that handle have been com-
             pleted.



             compressor_num_to_name




 Prototype   string compressor_num_to_name(int: compressor);

 Arguments   compressor     An integer index for a compression program in
             compress.cfg.

 Return Val. A string containing the name of the compressor, or the null
             string ("") if the compressor index is invalid.

 Description This function is used to translate the usr.compress field in
             the user structure to obtain a human-readable string.



             create_static_data




 Prototype   int create_static_data(string: key, long: size);

 Arguments   key   A string containing a used-defined key. This key iden-
             tifies the data item to be created. This string must be used
             to identify this data item in all future calls to the



             15. MEX Library Reference                                 282

             *_static_data functions. The recommended format for the key
             string is:

                   "program_name : program_specific_value", where pro-
                   gram_name is the name of the MEX program being exe-
                   cuted, and program_specific_value is a brief descrip-
                   tion of the item to be stored.

             size  The size of the data object to be created. The value
             used for this parameter is normally obtained by using the
             sizeof operator on the type of the object to be stored.

 Return Val. 0 if the data object was created successfully;
             -1 if not enough memory was available to satisfy the request;
             -2 if an invalid parameter was specified;
             -3 if the key name already exists.

 Description Normal MEX variables are destroyed as soon as the calling MEX
             program returns to Maximus, but the create_static_data func-
             tion allows programs to create persistent data  objects that
             remain around for an entire Maximus session.

             This function is used to store integral data types (char, int
             and long) and aggregates (user-defined struct and array
             types). To manipulate strings, see create_static_string.

             The size parameter should indicate the size of the data to be
             stored within the static data object. The sizeof operator is
             normally used to calculate this value. For example, if a long
             is to be stored, size should be set to sizeof(long).

             Static data objects created by create_static_data are ini-
             tially set to binary zeroes.

 Example     The following code demonstrates how to create a static data
             object called "myfoo" from test.mex. The data object is large
             enough to hold a "foo" structure:

                struct foo
                {
                  int: bar;
                  int: boz;
                };

                // ...

                struct foo: myfoo;

                create_static_data("test:current_foo",
                                   sizeof(struct foo));



             15. MEX Library Reference                                 283


             create_static_string




 Prototype   int create_static_string(string: key);

 Arguments   key   A string containing a used-defined key. This key is
             used to identify the data item to be created. This string
             must be used to identify this data item to all future calls
             to the *_static_data functions. The recommended format for
             the key string is:

                    "program_name : program_specific_value", where pro-
                   gram_name is the name of the MEX program being exe-
                   cuted, and program_specific_value is a brief descrip-
                   tion of the string to be stored.

 Return Val. 0 if the string was created successfully;
             -1 if not enough memory was available to satisfy the request;
             -2 if an invalid parameter was specified;
             -3 if the key name already exists.

 Description This function is similar to create_static_data, except that
             it creates persistent string variables. Maximus will manage
             the string size internally, so no size parameter is required
             for create_static_string.

             A string created by create_static_string is initially empty.

             For more information, see the description for cre-
             ate_static_data.

 Example     This code shows how to create a static string called
             "mystring" from test.mex:

                create_static_string("test:mystring");


             dcd_check




 Prototype   int dcd_check(int: state);

 Arguments   state A flag indicating whether or not DCD checking is to be
             used. If non-zero, DCD checking is performed. If zero, DCD
             checking is not performed.

 Return Val. An integer describing the prior state of DCD checking. A
             value of 1 indicates that DCD checking was previously being



             15. MEX Library Reference                                 284

             performed; a value of 0 indicates that DCD checking was not
             being performed.

 Description This function is used to control whether or not Maximus
             checks the DCD line. Normally, the absence of DCD indicates
             that the caller has hung up. However, some special MEX pro-
             grams may wish to ignore this signal, such as in call-back
             verifier programs.

             When automatic DCD checking is off, the carrier function can
             be used to manually check for DCD.



             destroy_static_data




 Prototype   int destroy_static_data(string: key);

 Arguments   key   The key for the static data object to be destroyed.
             This must be the same as the key parameter passed to cre-
             ate_static_data.

 Return Val. 0 if the data object was destroyed successfully;
             -1 if the key name was not found

 Description This function destroys a static object key and the corre-
             sponding object data, and it then returns the associated mem-
             ory to Maximus. This code must be called whenever a static
             data object is no longer required.

 Example     To destroy the static data object that was created in the ex-
             ample for the create_static_data function:

                destroy_static_data("test:current_foo");


             destroy_static_string




 Prototype   int destroy_static_string(string: key);

 Arguments   key   The key for the static string to be destroyed. This
             must be the same as the key parameter passed to cre-
             ate_static_string.

 Return Val. 0 if the string was destroyed successfully;
             -1 if the key name was not found



             15. MEX Library Reference                                 285

 Description This function destroys a static string key and the corre-
             sponding string data, and it then returns the associated mem-
             ory to Maximus. This code must be called whenever a static
             string is no longer required.

 Example     To destroy the static string that was created in the example
             for the create_static_string function:

                destroy_static_string("test:mystring");


             display_file




 Prototype   int display_file(string: filename, ref char: nonstop);

 Arguments   filename  The name of the .bbs file to be displayed to the
             user. If no extension is provided, ".bbs" is assumed.

                   WARNING!

                   All backslashes must be escaped in MEX programs. For
                   example, to specify a file called \max\misc\foo.bbs,
                   the parameter must contain "\\max\\misc\\foo.bbs".

             nonstop   A reference to a variable used for controlling non-
             stop display action. See the description and examples below
             for more information.

 Return Val. 0 if the file was displayed successfully;
             -1 otherwise.

 Description This function is used to display a .bbs file from within a
             MEX program. Any .bbs file can be displayed, as long as it
             does not try to recursively call another MEX program.

             The nonstop parameter is used to control non-stop file dis-
             play. In most cases, this variable should be initialized to 0
             before calling display_file and then left alone.

             If nonstop is set to 0 before calling display_file, normal
             "More" processing will take effect. Maximus will prompt the
             user with "More [Y,n,=]"  after every page of information has
             been displayed. If the user selects "=" at a More prompt, the
             nonstop parameter will be updated with a value of 1.

             If nonstop is set to 1 before calling display_file, Maximus
             will assume that the user already asked for non-stop display,
             so it will not prompt the user after every page.



             15. MEX Library Reference                                 286

             The nonstop variable can be used to implement the non-stop
             display of multiple files at a time.

 Example     This code shows how to display a single file:

                #include <max.mh>

                int main()
                {
                  char: nonstop;

                  nonstop := 0;
                  display_file("c:\\max\\misc\\logo.bbs", nonstop);

                  return 0;
                }

             This code shows how to display multiple files in succession,
             allowing for continuous display:

                #include <max.mh>

                int main()
                {
                  char: nonstop;

                  nonstop := 0;     // only initialize to 0 for
                                    // the first display

                  display_file("c:\\max\\misc\\logo.bbs", nonstop);
                  display_file("c:\\max\\misc\\welcome.bbs",
                               nonstop);

                  return 0;
                }

             The above code would display c:\max\misc\logo.bbs to the
             user, followed by c:\max\misc\welcome.bbs. If the user re-
             quested non-stop output while displaying logo.bbs, the wel-
             come.bbs file would also be displayed in non-stop mode. If
             this is not desired, nonstop should be set to 0 before each
             call to display_file.



             do_more




 Prototype   int do_more(ref char: nonstop, string: color);



             15. MEX Library Reference                                 287

 Arguments   nonstop   A reference to a variable used to store the non-
             stop display status. This variable is normally initialized by
             a call to the reset_more function.

             color A string containing the color to be used for displaying
             the More prompt. (This is normally one of the COL_* constants
             from mex.mh.)

 Return Val. TRUE if less than a page of information has been displayed
             since the last reset_more call, if the user answered "yes"
             or "=" at the prompt displayed by do_more, or if non-stop
             display is in effect; FALSE otherwise.

 Description This function is used to display "More [Y,n,=]" prompts to
             the user in appropriate places. This is useful when display-
             ing a long list of information that is longer than one
             screen.

             The do_more function keeps track of the number of lines that
             have been displayed since the last reset_more call. If the
             line count is less than the length of the screen, do_more
             will do nothing and return TRUE.

             If the line count is greater than or equal to the length of
             the screen, do_more will display a "More [Y,n,=]" prompt and
             reset the displayed line count, as long as the nonstop vari-
             able has a value of 0:

             If the user answers "N" at the prompt, do_more will return
             FALSE.

             If the user answers "Y" at the prompt, do_more will return
             TRUE.

             If the user answers "=" at the prompt, do_more will return
             TRUE and set the value of nonstop to 1.

             However, do_more will not display a More prompt to the user
             if the nonstop variable contains a value of 1 upon entry to
             the do_more function.

             For a final special case, if the nonstop variable has a value
             of -1, do_more  will always prompt the user for more, as in
             the case where nonstop was 0, as above. However, the value of
             nonstop will never be changed. Consequently, setting nonstop
             to -1 ensures that the More prompt will be displayed to the
             user after every page, even if the user specifically selects
             the "=" option.

 Example     For example, to display output with paging support provided
             by the do_more function:

                #include <max.mh>



             15. MEX Library Reference                                 288


                int main()
                {
                  int: line;
                  int: done;
                  char: nonstop;

                  reset_more(nonstop);
                  done := 0;

                  for (line := 1;
                       line <= 100 and done=0;
                       line := line + 1)
                  {
                       print("Line #", line, '\n');

                       if (do_more(nonstop, COL_WHITE) = 0)
                            done := TRUE;
                  }

                  return 0;
                }


             file_area




 Prototype   void file_area();

 Arguments   None

 Return Val. None

 Description This function displays the file area menu. Calling file_area
             is equivalent to calling menu_cmd(MNU_FILE_AREA, ""), al-
             though calling file_area is slightly faster.



             fileareafindclose




 Prototype   void fileareafindclose();

 Arguments   None

 Return Val. None



             15. MEX Library Reference                                 289

 Description The fileareafindclose function terminates an existing
             fileareafindfirst search. This function should be called
             whenever the program has finished using the file area data
             file.



             fileareafindfirst




 Prototype   int fileareafindfirst(ref struct _farea: fa, string: name,
             int: flags);

 Arguments   fa    A reference to a file area information structure. If
             this function finds a file area matching the name and flags
             parameters, information about that file area will be placed
             in this structure.

             name  Name of a specific file area to find. If name is the
             null string (""), this function will find the first available
             file area.

             flags A flag indicating whether or not FileDivisionBegin and
             FileDivisionEnd records are to be returned. If this flag is
             equal to AFFO_DIV, division records will be returned. Other-
             wise, if this flag is equal to AFFO_NODIV, division records
             will be skipped.

 Return Val. TRUE if an area was found; FALSE otherwise.

 Description The fileareafindfirst function searches for a specific file
             area, as specified by the name parameter. It also finds divi-
             sion records within the area file if the AFFO_DIV flag is
             specified.

             Only areas which can be accessed by the user will be returned
             by this function. This function will also skip file areas
             that have the Type Hidden style.

 Example     The following code will display a list of all file areas:

                #include <max.mh>

                int main()
                {
                  struct _farea: fa;

                  if (fileareafindfirst(fa, "", AFFO_NODIV))
                  {
                       do
                       {



             15. MEX Library Reference                                 290

                            print("Area: ", fa.name, '\n');
                       }
                       while (fileareafindnext(fa));

                       fileareafindclose();
                  }

                  return 0;
                }


             fileareafindnext




 Prototype   int fileareafindnext(ref struct _farea: fa);

 Arguments   fa    A reference to the file area structure to be updated
             with file area information. This structure must have been
             originally filled in by a fileareafindfirst, fileareaf-
             indnext, or fileareafindprev call.

 Return Val. TRUE if another file area was found; FALSE if no file area
             could be found.

 Description The fileareafindnext function finds the next file area that
             is accessible to the user. The search is carried out from the
             position where the last fileareafindnext, fileareafindprev,
             or fileareafindfirst call terminated. Consequently, if the
             last fileareafind* call returned information for area "X",
             this function would return information for the next user-
             accessible area following area "X".



             fileareafindprev




 Prototype   int fileareafindprev(ref struct _farea: fa);

 Arguments   fa    A reference to the file area structure to be updated
             with file area information. This structure must have been
             originally filled in by a fileareafindfirst, fileareaf-
             indnext, or fileareafindprev call.

 Return Val. TRUE if another file area was found; FALSE if no file area
             could be found.

 Description The fileareafindprev function finds the previous file area
             that is accessible to the user. The search is carried out



             15. MEX Library Reference                                 291

             from the position where the last fileareafindnext, fileareaf-
             indprev, or fileareafindfirst call terminated. Consequently,
             if the last fileareafind* call returned information for area
             "X", this function would return information for the first
             user-accessible area that precedes area "X".



             fileareaselect




 Prototype   int fileareaselect(string: name);

 Arguments   name  Name of the file area to be selected as the user's cur-
             rent file area.

 Return Val. TRUE if the area was successfully selected; FALSE otherwise.

 Description The fileareaselect function is used to change the user's cur-
             rent file area. Upon return, this function also updates the
             global farea variable with information about the new file
             area.



             filecopy




 Prototype   int filecopy(string: old, string: new);

 Arguments   old   Name of the file to be copied.

                   WARNING!

                   All backslashes must be escaped in MEX programs. For
                   example, to specify a file called \max\misc\foo.bbs,
                   the parameter must contain "\\max\\misc\\foo.bbs".

             new   Target path and filename for the copy.

 Return Val. TRUE if the file was successfully copied; FALSE otherwise.

 Description This function copies a file from old to new.



             15. MEX Library Reference                                 292


             filedate




 Prototype   int filedate(string: filename, ref struct stamp: fdate);

 Arguments   filename  The name of the file to be queried.

                   WARNING!

                   All backslashes must be escaped in MEX programs. For
                   example, to specify a file called \max\misc\foo.bbs,
                   the parameter must contain "\\max\\misc\\foo.bbs".

             fdate A reference to a stamp structure that will be updated
             to contain information about the file's date.

 Return Val. This function returns TRUE if the file date was successfully
             obtained; FALSE otherwise.

 Description The filedate function is used to obtain the last-write date
             for a specific file.



             fileexists




 Prototype   int fileexists(string: filename);

 Arguments   filename  The name of the file to be queried.

                   WARNING!

                   All backslashes must be escaped in MEX programs. For
                   example, to specify a file called \max\misc\foo.bbs,
                   the parameter must contain "\\max\\misc\\foo.bbs".

 Return Val. TRUE if the file exists; FALSE otherwise.

 Description This function is used to determine whether or not the speci-
             fied file exists on disk.



             15. MEX Library Reference                                 293


             filefindclose




 Prototype   void filefindclose(ref struct _ffind: ff);

 Arguments   ff    A reference to the _ffind structure that was returned
             by a previous call to filefindfirst.

 Return Val. None

 Description This function releases the system resources that were allo-
             cated when performing a filefindfirst call.



             filefindfirst




 Prototype   int filefindfirst(ref struct _ffind: ff, string: filename,
             int: attribs);

 Arguments   ff    A reference to a _ffind structure to be updated by this
             function. Upon return, this structure is updated with infor-
             mation about the file found (if any).

             filename  A wildcard specification (or individual filename)
             for which this function is to search.

             attribs   A set of  attributes used to describe the types of
             files to find. This should be FA_NORMAL in most cases, but it
             can also be one or more of the following, connected using the
             bitwise or operator: FA_READONLY, FA_HIDDEN, FA_SYSTEM,
             FA_VOLUME, FA_SUBDIR, or FA_ARCHIVE. This mask restricts the
             filenames returned to those which have the specified attrib-
             utes.

 Return Val. TRUE if a file was successfully found; FALSE otherwise.

 Description This function is normally used to expand file or directory
             wildcards. Given a filename specification such as "A*.*", the
             filefindfirst function will search for the specified file us-
             ing the host operating system.

             The first file matching filename will be returned in the ff
             structure, including information about the file's name, size,
             date and attributes.  (However, for finding file information
             for a single, non-wildcard filename, the filesize and fileex-
             ists functions are generally much faster.)



             15. MEX Library Reference                                 294

             To find the second and subsequent files that match the speci-
             fied wildcard, see the filefindnext function.

 Example     This code displays all of the files in the current directory:

                #include <max.mh>

                int main()
                {
                  struct _ffind: ff;

                  if (filefindfirst(ff, "*.*", FA_NORMAL))
                  {
                       do
                       {
                            print("Found file: ",
                                  ff.filename, '\n');
                       }
                       while (filefindnext(ff));

                       filefindclose(ff);
                  }

                  return 0;
                }


             filefindnext




 Prototype   int filefindnext(ref struct _ffind: ff);

 Arguments   ff    A reference to the _ffind structure that was returned
             by a previous call to filefindfirst.

 Return Val. TRUE if another file was found; FALSE otherwise.

 Description The filefindnext function continues a search that was started
             by filefindfirst.  This function returns the next filename
             matching the pattern specified in the original filefindfirst
             call.



             filesize




 Prototype   long filesize(string: filename);



             15. MEX Library Reference                                 295

 Arguments   filename  The filename whose size is to be queried.

                   WARNING!

                   All backslashes must be escaped in MEX programs. For
                   example, to specify a file called \max\misc\foo.bbs,
                   the parameter must contain "\\max\\misc\\foo.bbs".

 Return Val. -1 if the file does not exist; otherwise, this function re-
             turns the file size.

 Description The filesize function is used to retrieve the size of a file.



             get_static_data




 Prototype   int get_static_data(string: key, ref void: data);

 Arguments   key   The key for the static data object to be retrieved.
             This must be the same as the key parameter originally passed
             to create_static_data.

             data  A reference to the local data object that is to be up-
             dated with a copy of the static data object. Note that this
             parameter is a void reference, meaning that any type of ob-
             ject (char, int, long, array or struct) can be referenced.

 Return Val. 0 if the data object was retrieved successfully;
             -1 if the key name was not found.

 Description The get_static_data function is used to retrieve data that
             was previously stored by the set_static_data function. If key
             is a valid static data key that was created by cre-
             ate_static_data, this function will retrieve the information
             in the static data object and copy it into the local variable
             referenced by data.

 Example     The following code creates a static data object, writes a
             value to it, and then retrieves it again (without error
             checking):

                #include <max.mh>

                int main()
                {
                  long: l1, l2;
                  string: dataname;

                  dataname := "test:mylong";



             15. MEX Library Reference                                 296

                  create_static_data(dataname, sizeof(long));
                  l1 := 1234;
                  set_static_data(dataname, l1);

                  // Do some other things here, or even exit back
                  // to Maximus and restart the MEX program.

                  get_static_data(dataname, l2);
                  print("l2 = ", l2, '\n');
                  return 0;
                }


             get_static_string




 Prototype   int get_static_string(string: key, ref string: data);

 Arguments   key   The key for the static string to be retrieved. This
             must be the same as the key parameter passed to cre-
             ate_static_string.

             data  A reference to the string to be updated with a copy of
             the static string.

 Return Val. 0 if the string was retrieved successfully;
             -1 if the key name was not found.

 Description The get_static_string function is used to retrieve strings
             that were previously stored by the set_static_string func-
             tion. If key is a valid static string key that was created by
             create_static_string, this function will retrieve the infor-
             mation in the static string and copy it into the local string
             referenced by data.

 Example     The following code creates a static string, writes a value to
             it, and then retrieves it again (without error checking):

                #include <max.mh>

                int main()
                {
                  string: s1, s2;
                  string: stringname;

                  stringname := "test:mystring";
                  create_static_string(stringname);
                  s1 := "foo";
                  set_static_string(stringname, s1);

                  // Do some other things here, or even exit back



             15. MEX Library Reference                                 297

                  // to Maximus and restart.

                  get_static_string(stringname, s2);
                  print("s2 = '", s2, "'\n");
                  return 0;
                }



             getch




 Prototype   char getch();

 Arguments   None

 Return Val. The character entered by the user.

 Description This function performs raw character input. It simply returns
             the character typed by the user. If no character is avail-
             able, Maximus will wait until the user presses a key.

             All of the normal Maximus input routines are used, so if the
             system operator enables local keyboard input, characters en-
             tered at the local console will also be retrieved by this
             function.

             Note that this function does not perform any input process-
             ing. Regardless of the user's hotkey setting, IBM characters
             setting, or other flags, Maximus will simply return the char-
             acter received over the modem. This includes scan codes and
             raw key codes from terminal programs running in "doorway
             mode" (and from the local console).

             Except in special cases where raw keyboard input is required,
             the input_ch function should be used instead of this func-
             tion. input_ch provides access to formatted data input, in-
             cluding command stacking for non-hotkey users, prompts, and
             more.



             hstr




 Prototype   string hstr(ref string: heapname, int: index);

 Arguments   heapname  Name of the heap from which the string is to be
             fetched.



             15. MEX Library Reference                                 298

             index Index number (within the heap) of the string to be
             fetched.

 Return Val. The string that matches the requested heap name and index, or
             the null string ("") if the heap/index pair could not be
             found.

 Description The hstr function is used to retrieve strings from MEX-
             specific language files. The heapname and index parameters
             combine to form a key that refers to a unique string in one
             of the user-defined language heaps in english.mad.

             This function is only used to retrieve MEX-specific strings
             from english.mad. These strings are always contained in heaps
             that start with an "=" character, rather than the ":" charac-
             ter that is used to begin the standard system language heaps.

             Calls to hstr are normally generated automatically by MAID
             when it creates the english.mh include file for MEX programs.
             When MAID parses a language file, it gathers information
             about all of the user-defined heaps. It then translates the
             name in front of each string into a MEX #define directive,
             which expands into a call to the hstr function using the cor-
             rect heapname and index parameters.



             input_ch




 Prototype   int input_ch(int: type, string: options);

 Arguments   type  This parameter specifies a number of options that con-
             trol the character input routine. Zero or more of the CIN-
             PUT_* constants can be specified, combined using the bitwise
             or operator. For a detailed list of CINPUT_ constants, see
             the description below.

             options   This string specifies an optional list of parame-
             ters. The contents of this string vary based on the settings
             used for type, as described below.

 Return Val. This function returns the character that is entered by the
             user.

 Description The input_ch function performs formatted character input. It
             calls the standard Maximus character input routines to get a
             key from the user. Among other things, this means that:

                Hotkey mode is properly handled. If the user has hotkeys
                enabled, the function will return as soon as a key is



             15. MEX Library Reference                                 299

                pressed. Otherwise, Maximus will accept a line of input and
                only return the first character.

                Standard Maximus input functionality can also be enabled,
                such as prompt display and <ctrl-c> handling.

                Command stacking is supported.

             The type field controls how the input function operates. The
             field can be a combination of one or more of the values shown
             in Table 15.36. Multiple values can be combined using the
             bitwise or operator.

             Table 15.36 Character Input Types

              Type                 Description

              CINPUT_DISPLAY       The character entered by the user
                                   should always be displayed, even if
                                   hotkey mode is enabled. This option
                                   is implied for the input_list func-
                                   tion.
              CINPUT_ACCEPTABLE    Restrict the characters input by the
                                   user to the list of characters speci-
                                   fied in the options string. For exam-
                                   ple, if the CINPUT_ACCEPTABLE flag is
                                   specified, and if options contains
                                   "abeq", the user will only be able to
                                   enter an "A," "B," "E" or "Q" at the
                                   prompt.
              CINPUT_PROMPT        Display the prompt contained in op-
                                   tions before asking for input.
              CINPUT_SCAN          Accept scan codes. This option in-
                                   structs Maximus to return scan codes
                                   produced by function keys, cursor
                                   keys, and other special characters.
                                   (These scan codes can be created by
                                   pressing the appropriate function and
                                   cursor keys on the local SysOp key-
                                   board, and they can also be created
                                   by remote users who use terminal pro-
                                   grams in "DoorWay mode.")
                                   Although standard ASCII characters
                                   (such as letters, numbers, and punc-
                                   tuation) are still returned as a sin-
                                   gle character, when a function key or
                                   other non-ASCII character is pressed,
                                   input_key will return 0. In the fol-
                                   lowing call to input_key, the scan
                                   code of the key will be returned.
              CINPUT_NOXLT         Do not translate special characters,
                                   such as carriage returns and
                                   newlines, into their ASCII equiva-



             15. MEX Library Reference                                 300

                                   lents. (For example, unless this op-
                                   tion is used, <enter> will be re-
                                   turned as "|.") This option is im-
                                   plied for the input_list function.
              CINPUT_NOCTRLC       Do not allow the user to press <ctrl-
                                   c> to abort the current entry and re-
                                   display the prompt.
              CINPUT_P_CTRLC       The prompt specified in options will
                                   not be initially displayed; the
                                   prompt is only displayed if the user
                                   presses <ctrl-c>.
              CINPUT_NOLF          Do not display a linefeed after the
                                   user's input character selection is
                                   displayed.
              CINPUT_FULLPROMPT    Do not add a bracketed list of ac-
                                   ceptable characters to the prompt
                                   string. This option is only valid
                                   when used as parameter for the in-
                                   put_list function.
              CINPUT_ALLANSWERS    Allow the user to exit by pressing
                                   only <enter>, even if CIN-
                                   PUT_ACCEPTABLE is also specified.
              CINPUT_DUMP          Flush the output buffer when a char-
                                   acter is received. This option is
                                   mostly useful in hotkey mode. This
                                   option is also implied for the in-
                                   put_list function.
              CINPUT_NOUPPER       Do not convert received characters to
                                   uppercase.
              CINPUT_AUTOP         Display the prompt, even if the user
                                   has hotkeys enabled.
              CINPUT_ANY           Any response to this function is
                                   valid, even if not contained in list.
                                   This option is only valid when used
                                   as a parameter for the input_list
                                   function.



             input_list




 Prototype   int input_list(string: list, int: type, string: help_file,
             string: invalid,
                  string: prompt);

 Arguments   list  This string contains a list of acceptable input charac-
             ters. To allow a character that is not present in list, in-
             clude the CINPUT_ANY option in the type parameter. The first
             uppercase character in the string will be chosen as the de-



             15. MEX Library Reference                                 301

             fault option and will be selected if the user presses <enter>
             at the prompt.

             type  This parameter specifies a number of options that con-
             trol the character input routine. Zero or more of the CIN-
             PUT_* constants can be combined using the bitwise or opera-
             tor. For a detailed list of acceptable CINPUT_ constants, see
             the description of the input_ch function, above.

             help_file If not a blank string, this specifies the name of
             the help file to be displayed when a question mark ("?") is
             entered by the user. If this is not a blank string, Maximus
             will also add a "=help" to the end of prompt.

             invalid   This string is displayed to the user when an inva-
             lid character is entered.

             promptThis string contains a prompt to be displayed to the
             user. Unless the CINPUT_FULLPROMPT option is included in the
             type parameter, a bracketed list of acceptable option letters
             is automatically added to the end of this string.

 Return Val. This function returns the option character entered by the
             user.

 Description The input_list function prompts the user to enter a character
             from a predefined set of options. A typical prompt generated
             by input_list looks something like this:

                Do you prefer lettuce, cabbage or broccoli [L,c,b]?

             The first part of the prompt, "Do you prefer lettuce, cabbage
             or broccoli," is provided in the prompt parameter.

             The second part of the prompt, "[L,c,b]?" is automatically
             added by input_list. By specifying the valid input characters
             in the list string as "Lcb," the input_list function will
             automatically format the "[L,c,b]" text and add the final
             question mark. Since the "L" is uppercase, it will be chosen
             as the default option if the user presses <enter>.

 Example     The following code implements the prompt described above:

                #include <max.mh>

                int main()
                {
                  int: ch;

                  ch := input_list("Lcb",
                                   0,
                                   "",
                                   "That is an invalid type of "



             15. MEX Library Reference                                 302

                                     "produce. ",
                                   "Do you prefer lettuce, "
                                  "cabbage or broccoli");

                  return 0;
                }



             input_str




 Prototype   int input_str(ref string: s, int: type, char: ch, int: max,
             string: prompt);

 Arguments   s     On return, this variable will be updated to contain the
             text entered by the user.

             type  This parameter contains one or more INPUT_* options,
             combined using the bitwise or operator, which control how
             Maximus reads input from the user. These options are de-
             scribed in more detail in the function description, below.

             ch    This special-purpose parameter is only used when a cer-
             tain subset of the INPUT_* options are specified in the type
             field, as indicated in the table below. Otherwise, this pa-
             rameter should be 0.

             max   The maximum length of the string to be returned in s.

             promptThe prompt to be displayed to the user before request-
             ing input.

 Return Val. This function returns the length of the string placed in s.

 Description The input_str function displays a prompt and waits for the
             user to enter a word or a string. This string is returned in
             the s parameter where it can be later examined by the MEX
             program.

             The type parameter specifies a number of options that control
             how the input function reacts to user input. It also controls
             whether or not command accepts a word or a string, and
             whether or not command stacking is allowed.

             The type parameter must contain exactly one of the following
             mutually-exclusive options: INPUT_LB_LINE, INPUT_NLB_LINE,
             and INPUT_WORD. All of the other parameters in Table 15.37
             are optional and can be specified in any combination.



             15. MEX Library Reference                                 303

             Table 15.37 Line Input Types

              Type                 Description

              INPUT_LB_LINE        Read an entire line of input from the
                                   user. Command stacking is enabled, so
                                   if any unused input is in the stack-
                                   ing buffer (accessible as the global
                                   variable input), it will be returned
                                   without displaying the prompt or ask-
                                   ing the user for more input.
              INPUT_NLB_LINE       Read an entire line of input from the
                                   user. Command stacking is disabled,
                                   so the contents of the line buffer
                                   (accessible as the global variable
                                   input) are ignored. The prompt is al-
                                   ways displayed and the user is always
                                   asked for input.
              INPUT_WORD           Read a single word from the user.
                                   Command stacking is always enabled.
                                   If there is unused input in the
                                   stacking buffer (accessible as the
                                   global variable input), the first
                                   word therein will be returned without
                                   displaying the prompt or asking the
                                   user for more input. In this context,
                                   a "word" is delimited by one or more
                                   spaces. If the stacking buffer is
                                   empty, the prompt will be displayed
                                   and Maximus will wait for the user to
                                   enter an entire string. The first
                                   word of this string (delimited by
                                   spaces) will be returned, and the
                                   rest of the string will remain in the
                                   line buffer.

              INPUT_ECHO           The character specified in ch is ech-
                                   oed back instead of the actual char-
                                   acter typed by the user. This is use-
                                   ful for designing prompts for pass-
                                   words or other sensitive information.
                                   This option and INPUT_NOECHO are mu-
                                   tually exclusive. (If neither option
                                   is specified, Maximus will echo the
                                   characters normally.)
              INPUT_NOECHO         Do not echo any characters back to
                                   the remote. This option and IN-
                                   PUT_ECHO are mutually exclusive.

              INPUT_ALREADYCH      Pretend that the user has already en-
                                   tered the character given in ch. This
                                   is useful if an input sequence is
                                   chained off a hotkeyed menu option,



             15. MEX Library Reference                                 304

                                   or some other form of input that re-
                                   trieves the first input character
                                   manually.
              INPUT_SCAN           Allow scan codes to be placed in the
                                   returned string. See the description
                                   of CINPUT_SCAN in the input_ch func-
                                   tion for more information on scan
                                   code formats.
              INPUT_NOCTRLC        Do not allow the user to press <ctrl-
                                   c> to abort the current input and re-
                                   display the prompt.
              INPUT_NOLF           Do not send a linefeed after the user
                                   has finished entering the string.
              INPUT_WORDWRAP       Allow word-wrapping.
              INPUT_NOCLEOL        Never issue clear-to-end-of-line
                                   (CLEOL) codes.
              INPUT_DEFAULT        On input, pretend that the contents
                                   of s were already entered by the
                                   user. This option is useful if the
                                   first part of an input string is to
                                   be automatically generated. (However,
                                   the user can use the backspace key to
                                   modify this input.) On output, s will
                                   be updated with the full string by
                                   the user.



             iskeyboard




 Prototype   int iskeyboard();

 Arguments   None

 Return Val. TRUE if the local keyboard mode is active; FALSE otherwise.

 Description This function is used to determine whether or not the local
             keyboard mode (toggled by the "A" character on the SysOp con-
             sole) is active.

             Note that local sessions are always considered to be running
             in local keyboard mode.



             15. MEX Library Reference                                 305


             issnoop




 Prototype   int issnoop();

 Arguments   None

 Return Val. TRUE if snoop mode is active; FALSE otherwise.

 Description This function determines whether or not Snoop mode is active.
             If snoop mode is enabled, the output sent to the remote user
             will also be echoed on the local screen. Snoop mode is en-
             abled on the local console by pressing the "N" key.



             itostr




 Prototype   string itostr(int: i);

 Arguments   i     The integer to be converted.

 Return Val. This function returns the string representation of the inte-
             ger.

 Description The itostr function is used to convert an integer to a
             string. The converted string contains the ASCII representa-
             tion of the integer, from -32768 to 32767. See the uitostr
             function for converting unsigned integers.

             This function is useful when strings must be mixed with the
             results of integral computations.

 Example     This code concatenates a string and a converted integer:

                #include <max.mh>

                int main()
                {
                  int: i1;
                  string: s;

                  i1 := 1000;
                  s := "MEX is used by " + itostr(i1) + "s of "
                       + "programmers";

                  print(s);



             15. MEX Library Reference                                 306

                  return 0;
                }



             kbhit




 Prototype   int kbhit();

 Arguments   None

 Return Val. TRUE if a character is waiting; FALSE otherwise.

 Description The kbhit function is used to determine if a character has
             been pressed by the remote user (or on the local console, if
             local keyboard mode is enabled).

             If a character has been pressed, any of the input_str, in-
             put_list, input_ch or getch functions can be used to retrieve
             the character.



             keyboard




 Prototype   int keyboard(int: state);

 Arguments   state The new state for keyboard mode. If this parameter is
             1, local keyboard mode is enabled. If this parameter is 0,
             local keyboard mode is disabled.

 Return Val. The prior state of the local keyboard setting.

 Description The keyboard function is used to set or reset the local key-
             board mode. This function is primarily useful when a MEX pro-
             gram wishes to explicitly allow the SysOp to enter charac-
             ters, even if local keyboard mode was originally off.

             The return value of this function can be used at a later
             point in time to reset local keyboard mode to its original
             state.



             15. MEX Library Reference                                 307


             language_num_to_name




 Prototype   string language_num_to_name(int: lang);

 Arguments   lang  An integer index for a language defined in the language
             control file.

 Return Val. A string containing the name of the language, or the null
             string ("") if the language index is invalid.

 Description This function is used to translate the usr.lang field in the
             user structure to obtain a human-readable string.



             localkey




 Prototype   int localkey();

 Arguments   None

 Return Val. TRUE if the last getch or kbhit returned a character that was
             entered on the SysOp console or by a local session; FALSE if
             the character was entered by a remote user.

 Description The localkey function is used to determine the source of the
             most recent keystroke. This function can be useful if the
             processing of a character depends on whether the key was en-
             tered by a remote user or by the SysOp (or a caller logged on
             at the console).



             log




 Prototype   void log(string: text);

 Arguments   text  Line to be placed in the system log. The first charac-
             ter of the string should indicate the priority of the log
             message, such as "!" or "#." The second and following charac-
             ters of the string represent the line to be logged.

 Return Val. None



             15. MEX Library Reference                                 308

 Description This function adds the specified line to the Maximus system
             log file.

 Example     Given the following code:

                log("!Could not find user record!");

             The code above would create a log entry similar to the one
             shown below:

                ! 12 Jul 95 15:33:02 MAX  Could not find user record!




             long_to_stamp




 Prototype   void long_to_stamp(long: time, ref struct _stamp: st);

 Arguments   time  A long integer containing the time value to be con-
             verted. The value contained in this parameter represents the
             number of seconds elapsed since January 1st, 1970 (UTC).

             st    A reference to a _stamp structure. Upon return, this
             structure will be updated with values representing the time
             given by time.

 Return Val. None

 Description This function is used to convert the result of the time func-
             tion into a human-readable result. The values placed in the
             st structure correspond to the current date and time, ex-
             pressed in terms of the current year, day, month, hour, min-
             ute and second.



             lstr




 Prototype   string lstr(int: index);

 Arguments   index An integer representing one of the strings in the eng-
             lish.mad language file.

 Return Val. The string specified by the index parameter, or the null
             string ("") if an invalid index number was specified.



             15. MEX Library Reference                                 309

 Description The lstr function is used to retrieve a string from the stan-
             dard strings in the system language file. (System language
             heaps are always declared in english.mad using the ":" char-
             acter. To contrast, user-specific heaps ---which are re-
             trieved using the hstr function ---are always declared using
             the "=" character.)

             To find the index for a particular string in the language
             file, add a "@MEX" prefix before the definition of the string
             in english.mad. When MAID writes out the english.lh file, it
             will generate a #define which automatically calls the lstr
             function using the appropriate string number.



             ltostr




 Prototype   string ltostr(long: l);

 Arguments   l     The long integer to be converted.

 Return Val. This function returns the string representation of the long
             integer.

 Description The ltostr function is used to convert a long integer to a
             string. The converted string contains the ASCII representa-
             tion of the long integer, from -2147483648 to 2147483647. See
             the ultostr function for converting unsigned longs.

             This function is useful when strings must be mixed with the
             results of integral computations.

 Example     See the description for the itostr function for a related ex-
             ample.



             mdm_command




 Prototype   int mdm_command(string: cmdstring);

 Arguments   cmdstring The command to be sent to the modem. This string
             uses all of the same translation characters as in the modem
             initialization and busy strings from the Maximus control
             files, such as "|" for <enter> and "~" for a one-second
             pause. Please see the Busy keyword in section 18.2.2 for more
             information.



             15. MEX Library Reference                                 310

 Return Val. TRUE if the string was transmitted successfully; FALSE other-
             wise.

 Description The mdm_command function transmits a command string to the
             modem. This function is normally only used when talking di-
             rectly to the modem, rather than when a user is on-line.



             mdm_flow




 Prototype   void mdm_flow(int: state);

 Arguments   state A flag describing the desired state of XON/XOFF flow
             control. If this flag is set to 1, XON/XOFF flow control will
             be enabled if the SysOp has enabled Mask Handshaking XON. If
             this flag is set to 0, XON/XOFF flow control will always be
             disabled.

 Return Val. None

 Description This function enables or disables software handshaking. Soft-
             ware handshaking normally needs to be disabled before trying
             to communicate directly with the modem.



             menu_cmd




 Prototype   void menu_cmd(int: cmdnum, string: args);

 Arguments   cmdnumThe MNU_* constant describing the menu option to exe-
             cute. The max_menu.mh header file must be included (with the
             #include directive) to define the MNU_* constants.

             args  Arguments for the menu command. These arguments are
             specified in string format. Most menu commands do not require
             arguments; the only functions which require arguments are
             those which have an argument specified in the second column
             in the menus control file. For all other menu option types,
             this string should be the null string ("").

 Return Val. None

 Description The menu_cmd function executes an internal Maximus menu com-
             mand. Sample actions include entering a message, performing a



             15. MEX Library Reference                                 311

             new files search, and invoking most of the other commands in
             menus.ctl.

             The main restrictions for menu_cmd are:

             *  The Display_File menu command cannot be invoked. (Instead,
                see the display_file MEX function.)

             *  The Edit_* menu commands cannot be invoked unless the user
                is already running either the MaxEd or the BORED editor.

             *  The MEX, Xtern_Erlvl, Link_Menu, Return and Display_Menu
                menu commands cannot be invoked.



             msg_area




 Prototype   void msg_area();

 Arguments   None

 Return Val. None

 Description This function displays the message area menu. Calling
             msg_area is equivalent to calling menu_cmd(MNU_MSG_AREA, ""),
             although calling msg_area is slightly faster.



             msgareafindclose




 Prototype   void msgareafindclose();

 Arguments   None

 Return Val. None

 Description The msgareafindclose function terminates an existing msgare-
             afindfirst search. This function should be called whenever
             the program has finished using the message area data file.



             15. MEX Library Reference                                 312


             msgareafindfirst




 Prototype   int msgareafindfirst(ref struct _marea: ma, string: name,
             int: flags);

 Arguments   ma    A reference to a message area information structure. If
             this function finds a message area matching the name and
             flags parameters, information about that message area will be
             placed in this structure.

             name  Name of a specific message area to find. If name is the
             null string (""), this function will find the first available
             message area.

             flags A flag indicating whether or not MsgDivisionBegin and
             MsgDivisionEnd records are to be returned. If this flag is
             equal to AFFO_DIV, division records will be returned. Other-
             wise, if this flag is equal to AFFO_NODIV, division records
             will be skipped.

 Return Val. TRUE if an area was found; FALSE otherwise.

 Description The msgareafindfirst function searches for a specific message
             area, as specified by the name parameter. It also finds divi-
             sion records within the area file if the AFFO_DIV flag is
             specified.

             Only areas which can be accessed by the user will be returned
             by this function. This function will also skip message areas
             that have the "Hidden" style.

 Example     The following code will display a list of all message areas:

                #include <max.mh>

                int main()
                {
                  struct _marea: ma;

                  if (msgareafindfirst (ma, "", AFFO_NODIV))
                  {
                       do
                       {
                            print("Area: ", ma.name, '\n');
                       }
                       while (msgareafindnext (ma));

                       msgareafindclose();
                  }



             15. MEX Library Reference                                 313


                  return 0;
                }



             msgareafindnext




 Prototype   int msgareafindnext(ref struct _marea: ma);

 Arguments   ma    A reference to the message area structure to be updated
             with message area information. This structure must have been
             originally filled in by a msgareafindfirst, msgareafindnext,
             or msgareafindprev call.

 Return Val. TRUE if another message area was found; FALSE if no message
             area could be found.

 Description The msgareafindnext function finds the next message area that
             is accessible to the user. The search is carried out from the
             position where the last msgareafindnext, msgareafindprev, or
             msgareafindfirst call terminated. Consequently, if the last
             msgareafind* call returned information for area "X", this
             function would return information for the next user-
             accessible area following area "X".



             msgareafindprev




 Prototype   int msgareafindprev(ref struct _marea: ma);

 Arguments   ma    A reference to the message area structure to be updated
             with message area information. This structure must have been
             originally filled in by a msgareafindfirst, msgareafindnext,
             or msgareafindprev call.

 Return Val. TRUE if another message area was found; FALSE if no message
             area could be found.

 Description The msgareafindnext function finds the previous message area
             that is accessible to the user. The search is carried out
             from the position the last msgareafindnext, msgareafindprev,
             or msgareafindfirst call terminated. Consequently, if the
             last msgareafind* call returned information for area "X",
             this function would return information for the first user-
             accessible area that precedes area "X".



             15. MEX Library Reference                                 314


             msgareaselect




 Prototype   int msgareaselect(string: name);

 Arguments   name  Name of the message area to be selected as the user's
             current message area

 Return Val. TRUE if the area was successfully selected; FALSE otherwise.

 Description The msgareaselect function is used to change the user's cur-
             rent message area. Upon return, this function also updates
             the global marea and msg structures with information about
             the new message area.



             open




 Prototype   int open(string: name, int: mode);

 Arguments   name  The name of the file to be opened.

                   WARNING!

                   All backslashes must be escaped in MEX programs. For
                   example, to specify a file called \max\misc\foo.bbs,
                   the parameter must contain "\\max\\misc\\foo.bbs".

             mode  One or more IOPEN_* constants specifying the mode to be
             used when opening the file. The bitwise or operator can be
             used to combine multiple IOPEN_ constants. This parameter is
             described below in more detail.

 Return Val. -1 if an error occurs; otherwise, open returns an integer
             which identifies the opened file. This identifier must be
             stored and passed to the other MEX I/O functions when the
             file is to be accessed.

 Description The open function opens a file.  Depending on the value of
             mode, this function can be used to open an existing file or
             create a new one.

             The mode parameter indicates the file-opening mode. mode
             should contain exactly one of the constants from Table 15.38.



             15. MEX Library Reference                                 315

             Table 15.38 File Open Modes

              Mode           Description

              IOPEN_READ     Open the file for reading
              IOPEN_WRITE    Open the file for writing



             In addition, any of the modifiers from Table 15.39 can also
             be used if IOPEN_WRITE is specified:

             Table 15.39 File Open Modifiers


              Mode            Description

              IOPEN_APPEND    Append to the end of the file.
              IOPEN_CREATE    Create the file if it does not exist, or
                              truncate the file if it does.
              IOPEN_BINARY    Open the file in binary mode. This option
                              suppresses the translation of end-of-line
                              characters.



 Example     The following code creates a file called c:\test.fil and
             makes the file ready for writing:

                int: fd;

                fd := open("c:\\test.fil",
                           IOPEN_CREATE | IOPEN_WRITE);


             print




 Prototype   void print(...);

 Arguments   Any number of parameters (with any type) can be specified.
             See the function description for more information.

 Return Val. None

 Description print is used to display text to the user. print can display
             any type of information, including characters, integers,
             strings, or even user-defined structures or data types.



             15. MEX Library Reference                                 316

             Any number of parameters may be specified to print, and all
             will be displayed using formatting routines appropriate to
             the data type.

             The print function displays the information specified in its
             parameters, but it does not automatically place the cursor on
             the next line. To add this functionality, include a `\n' pa-
             rameter at the end of the function call.

             print handles the data types shown in Table 15.40 by default:

             Table 15.40 Print Data Types

              Type      Description

              char      Display a character in its natural format. For
                        example, the character `A' will be displayed
                        simply as "A." Control characters and high-bit
                        characters will also be displayed as-is, al-
                        though all print output will pass through the
                        standard Maximus output filter. This means that
                        high-bit characters may sometimes be replaced
                        with ASCII equivalents, and terminal control se-
                        quences may be stripped. (See section 13 for
                        more information.)
              int       Display an integer in decimal. The range for
                        signed integers is minus 32768 to 32767.
              long      Display a long integer in decimal. The range for
                        longs is minus 2147483648 to 2147483647.
              unsigned  Display an unsigned integer in decimal. The
              int       range for unsigned integers is 0 to 65535.
              unsigned  Display an unsigned long in decimal. The range
              long      for unsigned longs is 0 to 4294967296.
              string    Display a string. The string will be displayed
                        just as if each of the characters inside had
                        been displayed individually as a char, as above.


             print itself is just a meta-function ---there is no real
             function called "print" in the MEX run-time library. However,
             when the compiler encounters a print statement, it splits
             apart all of the arguments and calls a separate function for
             each.

             For an argument with a type of mytype, the MEX compiler will
             generate a call to a function of the form:

                __printMYTYPE(data);

             where MYTYPE is the uppercase name of the type to be dis-
             played. The standard run-time library includes the following
             print handlers:



             15. MEX Library Reference                                 317

                __printSTRING
                __printLONG
                __printINT
                __printCHAR
                __printUNSIGNED_LONG
                __printUNSIGNED_INT
                __printUNSIGNED_CHAR

             Support for user-defined data types can also be added to
             print by defining a new print function to handle the appro-
             priate argument type. For example, given a data type and an
             appropriate print handler function:

                struct complex
                {
                  int: real;
                  int: imaginary;
                };

                void __printSTRUCT_COMPLEX(ref struct complex: c)
                {
                  print('(', c.real, ',', c.imaginary, ')');
                }

             With these definitions, the print function can be used to
             print a structure of type complex by simply passing the
             structure as a parameter:

                struct complex: c;

                c.real := 5;
                c.imaginary := 10;

                print("The complex number is ", c, ".\n");



             privok




 Prototype   int privok(string: acs);

 Arguments   acs   The Access Control String (ACS) to be checked.

 Return Val. TRUE if the user's privilege level passes the privilege level
             check; FALSE otherwise.

 Description The privok function is used to check a user's privilege level
             against a given Access Control String. The ACS check per-
             formed by this function is the same as in all other areas of



             15. MEX Library Reference                                 318

             Maximus, so all of the standard ACS modifiers (">=", "!", and
             so on) can be specified in acs.



             prm_string




 Prototype   string prm_string(int: stringnum);

 Arguments   stringnum The string number to be retrieved from the Maximus
             .prm file. A string number of 0 specifies the first string.

 Return Val. The string that was retrieved, or the null string ("") if the
             string number is invalid.

 Description This function retrieves a string from the Maximus .prm file.
             The string number specifies an offset within the fixed-length
             string index table. The string numbers are version-specific
             and are subject to change without notice.



             protocol_num_to_name




 Prototype   string protocol_num_to_name(int: protocol);

 Arguments   protocol  An integer index for a protocol defined in proto-
             col.ctl.

 Return Val. A string containing the name of the protocol, or the null
             string ("") if the protocol index is invalid.

 Description This function is used to translate the usr.def_proto field in
             the user structure to obtain a human-readable string.



             read




 Prototype   int read(int: fd, ref string: s, int: len);

 Arguments   fd    A file descriptor, as returned by the open function.



             15. MEX Library Reference                                 319

             s     A reference to a string. Upon return, this string is
             filled in with the bytes read from the file.

             len   The maximum number of bytes to place into the string s.

 Return Val. If the return value is the same as len, the read was com-
             pletely successful.

             If the return value is less than len (but greater than zero),
             only a portion of the requested number of bytes could be
             read.

             If the return value is 0, end-of-file was encountered.

             If the return value is -1, an error occurred when trying to
             read from the file.

 Description The read function reads a block of bytes from the specified
             file handle. This function reads blocks of bytes at a time
             with no consideration for "lines" in the source file. To read
             a file a line at a time, see the readln function.



             readln




 Prototype   int readln(int: fd, ref string: s);

 Arguments   fd    A file descriptor, as returned by the open function.

             s     A reference to a string. Upon return, this string will
             be filled in with the line read from the file.

 Return Val. If the return value is greater than zero, this is the number
             of bytes placed into the string.

             If the return value is 0, end-of-file was encountered

             If the return value is -1, an error occurred when trying to
             read from the file.

 Description The readln function reads an entire line from the specified
             file handle. If the line ends with a newline character, it is
             automatically stripped.



             15. MEX Library Reference                                 320


             remove




 Prototype   int remove(string: file);

 Arguments   file  The name of the file to be deleted.

                   WARNING!

                   All backslashes must be escaped in MEX programs. For
                   example, to specify a file called \max\misc\foo.bbs,
                   the parameter must contain "\\max\\misc\\foo.bbs".

 Return Val. TRUE if the file was successfully deleted; FALSE otherwise.

 Description This function deletes the specified filename.



             rename




 Prototype   int rename(string: old, string: new);

 Arguments   old   The name of the file to be renamed.

                   WARNING!

                   All backslashes must be escaped in MEX programs. For
                   example, to specify a file called \max\misc\foo.bbs,
                   the parameter must contain "\\max\\misc\\foo.bbs".

             new   The new name to be assigned to the file.

 Return Val. TRUE if the rename operation was successful; FALSE otherwise.

 Description The rename function is used to rename or move an existing
             file. If the file is not in the current directory, full paths
             must be specified for both old and new.

             This function cannot be used to move files across drives.



             15. MEX Library Reference                                 321


             reset_more




 Prototype   void reset_more(ref char: nonstop);

 Arguments   nonstop   A reference to the non-stop control character. This
             character is initialized to a value of 0 by reset_more.

 Return Val. None

 Description The reset_more function resets the internal "More" counter
             that controls the number of screen lines remaining until a
             "More [Y,n,=]?" prompt is displayed. The current point in the
             display will be treated as the "top" of the current output
             page, insofar as more prompts are concerned.

             The nonstop variable is used in later calls to the do_more
             function (which is where the more prompts are actually dis-
             played).



             rip_detect




 Prototype   int rip_detect();

 Arguments   None

 Return Val. TRUE if the user's terminal supports RIPscrip graphics; FALSE
             otherwise.

 Description The rip_detect function is used to query the remote terminal
             to determine if it supports RIPscrip graphics. If the remote
             terminal reports that RIPscrip graphics are supported, this
             function returns TRUE.

             After the user has logged on, the user's current preference
             for RIPscrip graphics can be read from the usr.rip field.



             rip_hasfile




 Prototype   int rip_hasfile(string: fname, ref long: filesize);



             15. MEX Library Reference                                 322

 Arguments   fname The name of the remote file to query. This name must
             not have an explicit path.

             filesize  A reference to the size of the file to be queried.
             If filesize is set to -1, Maximus will query the remote for
             the size of the file and place it into this variable upon re-
             turn.

 Return Val. 1 if the remote user has the file;
             0 if the remote user does not have the file;
             -1 if a RIPscrip protocol error occurred

 Description The rip_hasfile function allows a MEX program to determine
             whether or not the remote user has a specified RIPscrip file.

             If an explicit filesize is provided, this function only re-
             turns TRUE if the remote user has the file and the file has
             the indicated size.

             Otherwise, if filesize is set to -1 before calling
             rip_hasfile, Maximus checks the remote side and sets the
             filesize parameter to the size of the remote file. It returns
             TRUE if the file exists and FALSE otherwise.



             rip_send




 Prototype   int rip_send(string: filename, int: display);

 Arguments   filename  The filename to be sent to the remote RIPscrip
             user. If no path is specified, Maximus will assume the cur-
             rent RIP Path.

             display   TRUE if the file is to be displayed as soon as it
             is sent; FALSE otherwise.

 Return Val. TRUE if the file was successfully displayed/sent; FALSE oth-
             erwise.

 Description This function is used to send a RIPscrip scene or icon file
             to the remote user. After sending the file, it can be option-
             ally displayed by setting the display parameter to TRUE.

             This performs a function equivalent to the [ripsend] MECCA
             token.



             15. MEX Library Reference                                 323


             screen_length




 Prototype   int screen_length();

 Arguments   None

 Return Val. The length of the local screen, in rows.

 Description The screen_length function returns the length of the local
             console screen.



             screen_width




 Prototype   int screen_width();

 Arguments   None

 Return Val. The width of the local screen, in columns.

 Description The screen_width function returns the width of the local con-
             sole screen.



             seek




 Prototype   int seek(int: fd, long: pos, int: where);

 Arguments   fd    A file descriptor, as returned by the open function.

             pos   The position to which the file should be seeked. This
             position is relative to the offset specified for the where
             parameter. Negative offsets are permitted if either SEEK_CUR
             or SEEK_END are specified for where.

             where This parameter defines the relation between the pos pa-
             rameter and the physical offset within the file. This is de-
             scribed in more detail below.

 Return Val. The new file offset, relative to the beginning of the file.



             15. MEX Library Reference                                 324

 Description The seek function moves the file pointer for the specified
             file to a new location. This function is used to jump to an
             arbitrary offset within a file, or to jump directly to the
             beginning or end of a file.

             The where parameter must be one of the values from Table
             15.41:

             Table 15.41 Seek Offsets

              Value    Description

              SEEK_CUR pos is relative to the current file position.
              SEEK_SET pos is relative to the beginning of the file.
              SEEK_END pos is relative to the end of the file.




             set_output




 Prototype   int set_output(int mode);

 Arguments   mode  This function sets the output control mode. This must
             be one of the DISABLE_* parameters described below.

 Return Val. The original setting for screen output. This return value can
             be used to restore the screen output mode at a later time by
             calling set_output again.

 Description This function allows the Maximus video output to be sup-
             pressed, for either the remote user, the local screen, or
             both.

             The mode parameter must be one of the values from Table
             15.42:

             Table 15.42 Output Disable Modes

              Value            Description

              DISABLE_NONE     Enable all output.
              DISABLE_LOCAL    Disable only local output.
              DISABLE_REMOTE   Disable only remote output.
              DISABLE_BOTH     Disable both local and remote output.



             15. MEX Library Reference                                 325


             set_static_data




 Prototype   int set_static_data(string: key, ref void: data);

 Arguments   key   The key for the static data object to be set. This must
             be the same as the key parameter passed to cre-
             ate_static_data.

             data  A reference to the local data object to store in the
             static data object. Note that this parameter is a void refer-
             ence, meaning that any type of object (char, int, long, array
             or struct) can be referenced.

 Return Val. 0 if the data object was stored successfully;
             -1 if the key name was not found.

 Description The set_static_data function is used to store data that can
             be retrieved later during the same Maximus session by the
             get_static_data function. Data stored by set_static_data is
             persistent, in that it retains its value even after the cre-
             ating MEX program has ended.

             If key is a valid static data key that was created by cre-
             ate_static_data, this function will copy the information from
             the local structure referenced by data into the static data
             object.



             set_static_string




 Prototype   int set_static_string(string: key, string: data);

 Arguments   key   The key for the static string to be set. This must be
             the same as the key parameter passed to create_static_string.

             data  The local string to be stored in the static string.

 Return Val. 0 if the string was stored successfully;
             -1 if the key name was not found;
             -2 if there was not enough memory to store the string.

 Description The set_static_string function is used to store strings that
             can be retrieved later during the same Maximus session by the
             get_static_string function. Strings stored by



             15. MEX Library Reference                                 326

             set_static_string are persistent, in that they retain their
             values even after the creating MEX program has ended.

             If key is a valid static string key that was created by cre-
             ate_static_string, this function will copy the information
             from the local string referenced by data into the static
             string.



             set_textsize




 Prototype   void set_textsize(int: cols, int: rows);

 Arguments   cols  The number of columns in the window.

             rows  The number of rows in the window.

 Return Val. None

 Description The set_textsize sets the assumed text window size of the re-
             mote system. This is primarily used to set the size of the
             display for "More" prompting when using RIPscrip windows on
             the remote terminal.

             Specifying values of 0 for either cols or rows will set the
             window width or length (respectively) back to the default, as
             specified in the user record.



             shell




 Prototype   int shell(int: method, string: cmd);

 Arguments   methodAn IOUTSIDE_* constant describing the method to use for
             executing the program. This parameter is described below in
             more detail.

             cmd   The name of the command to run, plus any optional pro-
             gram arguments.

                   WARNING!

                   All backslashes must be escaped in MEX programs. For
                   example, to specify a file called \max\misc\foo.bbs,
                   the parameter must contain "\\max\\misc\\foo.bbs".



             15. MEX Library Reference                                 327

 Return Val. The return value of the program, or -1 if the program could
             not be executed.

 Description The shell function invokes an external program or a secondary
             copy of the command interpreter. The exact method used for
             invoking the external program depends on the value of the
             method parameter. At least one of IOUTSIDE_RUN or IOUT-
             SIDE_DOS must be specified; the other parameters from Table
             15.43 are optional and can be combined using the bitwise or
             operator:

             Table 15.43 Outside Methods

              Value               Description

              IOUTSIDE_RUN        Spawn the program directly. This op-
                                  tion can only be used to run .exe and
                                  .com files in the operating system's
                                  native format. This method is faster
                                  than IOUTSIDE_DOS.
              IOUTSIDE_DOS        Execute the program through the com-
                                  mand interpreter. This option can be
                                  used to spawn .bat, .cmd. ,exe and
                                  .com files, in addition to internal
                                  shell commands (such as "dir" and
                                  "copy"). Under OS/2, this function can
                                  also be used to invoke DOS programs.
              IOUTSIDE_REREAD     After running the external program,
                                  re-read the user record from the las-
                                  tuser.bbs file. This flag can be com-
                                  bined with the IOUTSIDE_RUN or IOUT-
                                  SIDE_DOS flags using the bitwise or
                                  operator.



 Example     The following code displays a directory of the \MAX\MISC di-
             rectory:

                shell(IOUTSIDE_DOS, "dir c:\\max\\misc");


             sleep




 Prototype   void sleep(int: duration);

 Arguments   duration  The amount of time to sleep, measured in hundredths
             of seconds.

 Return Val. None



             15. MEX Library Reference                                 328

 Description The sleep function instructs Maximus to pause for a certain
             period of time. Since duration is measured in hundredths of
             seconds, a value of 500 would tell Maximus to sleep for five
             seconds.

             Under OS/2, this function can be used to temporarily yield
             control to other programs during a polling loop. Calling
             sleep(1) tells Maximus to yield for long enough for other
             programs to run, but also to return control to the MEX pro-
             gram quickly enough so that there is no noticeable lag in re-
             sponse time.



             snoop




 Prototype   int snoop(int: state);

 Arguments   state The new state for the console snoop mode. A value of
             TRUE enables snoop mode, while a value of FALSE disables
             snoop mode.

 Return Val. The original setting of snoop mode. This value can be used at
             a later time to restore the original snoop mode setting.

 Description The snoop function is used to set the state of the internal
             "snoop" feature. When snoop is enabled, the local console
             will show exactly what is displayed on the remote screen.



             stamp_string




 Prototype   string stamp_string(ref struct _stamp: t);

 Arguments   t     A reference to a structure containing date and time
             values.

 Return Val. A string version of the date and time, using the format
             specified in max.ctl.

 Description The stamp_string function converts a _stamp structure into a
             human-readable string, using the SysOp-defined time format in
             the max.ctl file.



             15. MEX Library Reference                                 329


             stamp_to_long




 Prototype   long stamp_to_long(ref struct _stamp: st);

 Arguments   st    A reference to a structure containing date and time
             values.

 Return Val. A long integer representing the number of seconds elapsed
             since January 1st, 1970 UTC.

 Description The stamp_to_long function converts a _stamp structure back
             into the format that is returned by the time function. This
             function is useful when the date/time entries into two _stamp
             structures need to be compared in terms of chronological or-
             der.



             strfind




 Prototype   int strfind(ref string: str, string: substring);

 Arguments   stringThe string to be searched.

             substring The substring to search for within string.

 Return Val. 0 if substring was not found; otherwise, the index in string
             at which substring is found. An index of 1 indicates the
             first byte in string.

 Description The strfind function tries to find an occurrence of substring
             within the master string str.

 Example     This shows how the strfind return value is used:

                #include <max.mh>

                int main()
                {
                  int: i;

                  i := strfind("This is a big string", "big");
                  print(i); // i = 11
                  return 0;
                }



             15. MEX Library Reference                                 330


             stridx




 Prototype   int stridx(string: src, int: startpos, int: ch);

 Arguments   src   The string to be searched.

             startpos  The position in src at which the search is to
             start.

             ch    The character to search for within src.

 Return Val. 0 if the character could not be found; otherwise, the index
             of the position containing the character.

 Description The stridx function searches the string specified by src for
             any occurrences of the character ch. If ch is found, it re-
             turns the index of that character within the string.

             This function searches the string from left to right, start-
             ing at the position specified. To search the string from
             right to left, see the strridx function.

 Example     To search for all instances of a character within a given
             string, the following code can be used:

                #include <max.mh>

                int main()
                {
                  int: pos;
                  string: src;

                  src := "Abcdxefghxijklmnoxpqxrxxst";
                  pos := 1;

                  for (pos := stridx (src, pos, 'x');
                       pos;
                       pos := stridx (src, pos+1, 'x'))
                  {
                       print("Found an 'x' at position ",
                             pos, '\n');
                  }

                  return 0;
                }



             15. MEX Library Reference                                 331


             strlen




 Prototype   int strlen(string: s);

 Arguments   s     The string to be measured.

 Return Val. The length of the string.

 Description The strlen function determines the length of a given string
             and returns it to the caller.

             An empty or uninitialized string has a length of 0.



             strlower




 Prototype   string strlower(string: src);

 Arguments   src   The string to be converted.

 Return Val. A lowercase version of the src string.

 Description This function converts a string to lowercase.



             strpad




 Prototype   string strpad(string: str, int: length, char: pad);

 Arguments   str   The string to be padded

             lengthThe length to which the string should be padded.

             pad   The character which should be used for padding the
             string.

 Return Val. The padded version of the string.

 Description The strpad function pads a string so that it is at least
             length characters long.



             15. MEX Library Reference                                 332

             If the string is already more than or equal to length charac-
             ters in length, the string is returned unchanged.

             If the string is less than length characters in length, the
             pad character is appended to the end of the string as many
             times as necessary to make the string exactly length charac-
             ters long.



             strpadleft




 Prototype   string strpadleft(string: str, int: length, char: pad);

 Arguments   str   The string to be padded

             lengthThe length to which the string should be padded.

             pad   The character which should be used for padding the
             string.

 Return Val. The padded version of the string.

 Description The strpadleft function pads a string so that it is at least
             length characters long.

             This function differs from strpad only in that the padding
             characters are added to the beginning of the string rather
             than at the end of the string.



             strridx




 Prototype   int strridx(string: src, int: startpos, int: ch);

 Arguments   src   The string to be searched.

             startpos  The position in src at which the search is to
             start. A value of 0 for startpos instructs Maximus to start
             searching from the end of the string.

             ch    The character to search for within src.

 Return Val. 0 if the character could not be found; otherwise, the index
             of the position containing the character.



             15. MEX Library Reference                                 333

 Description The strridx function searches the string specified by src for
             any occurrences of the character ch. If ch is found, it re-
             turns the index of that character within the string.

             This function searches the string from right to left, start-
             ing at the position specified, or at the end of the string if
             startpos is 0. To search the string from left to right, see
             the stridx function.

 Example     To search for all instances of a character within a given
             string, the following code can be used. (The character indi-
             ces are returned in order from right to left.)

                #include <max.mh>

                int main()
                {
                  string: src;
                  int: pos;

                  src := "Abcdxefgxijklmnxxopqxrxstux";
                  pos := 0;

                  for (pos := strridx(src, pos, 'x');
                       pos;
                       pos := strridx(src, pos-1, 'x'))
                  {
                       print("Found an 'x' at position ",
                             pos, '\n');
                  }

                  return 0;
                }


             strtoi




 Prototype   int strtoi(string: s);

 Arguments   s     The string containing the decimal representation of a
             number.

 Return Val. The integer equivalent of the string, or 0 if the string
             could not be converted.

 Description The strtoi function converts an ASCII string into an integer.
             The string must have a digit as its first character, and the
             number represented in the string must be in decimal.



             15. MEX Library Reference                                 334

             This function reads the string until it encounters a non-
             digit or the end of the string. All of the digits up to that
             point are converted and returned to the caller as an integer.

             This function can handle numbers in the range of -32768
             through 65535. However, the exact range of usable numbers de-
             pends on the type of integer to which the return code is as-
             signed.

             If the return code is assigned to an unsigned integer, values
             in the range 0 to 65535 are converted. Otherwise, if the re-
             turn code is assigned to a signed integer, values in the
             range -32768 to 32767 are converted. To handle larger num-
             bers, see the strtol function.



             strtok




 Prototype   int strtok(string: src, string: toks, ref int: pos);

 Arguments   src   The source string to be tokenized.

             toks  A string containing a list of acceptable token delimit-
             ers. These token delimiters are used to delimit where one to-
             ken ends and the following token begins. The end of the
             string is always considered to be a delimiter.

             pos   A reference to an integer containing the most-recently
             examined position in the string. On the initial call to
             strtok, this value should be set to 0. This variable is nor-
             mally updated by strtok, so applications should not need to
             modify pos after the first call to strtok.

 Return Val. A string containing the token, stripped of all token delimit-
             ers. If no more tokens exist in the string, the null string
             ("") is returned.

 Description The strtok function is used for parsing strings. It returns
             the substring in src, starting at position pos, which is de-
             limited by any of the characters in the toks string.

 Example     The following code tokenizes a string, using spaces and tabs
             as delimiters:

                #include <max.mh>

                int main()
                {
                  string: src, sub;



             15. MEX Library Reference                                 335

                  int: pos;

                  pos := 0;
                  src := "This is a test";

                  for (sub := strtok (src, " \t", pos);
                       sub <> "";
                       sub := strtok (src, " \t", pos))
                  {
                       print("Word is '", sub, "'\n");
                  }

                  // The program prints:
                  //
                  // Word is 'This'
                  // Word is 'is'
                  // Word is 'a'
                  // Word is 'test'

                  return 0;
                }



             strtol




 Prototype   int strtol(string: s);

 Arguments   s     The string containing the decimal representation of a
             number.

 Return Val. The long integer equivalent of the string, or 0 if the string
             could not be converted.

 Description The strtol function converts an ASCII string into a long in-
             teger. The string must have a digit as its first character,
             and the number represented in the string must be in decimal.

             This function reads the string until it encounters a non-
             digit or the end of the string. All of the digits up to that
             point are converted and returned to the caller.

             This function can handle numbers in the range of -2147483648
             to 4294967296. However, the exact range of usable numbers de-
             pends on the type of long integer to which the return code is
             assigned.

             If the return code is assigned to an unsigned long, values in
             the range 0 to 4294967296 are converted. Otherwise, if the



             15. MEX Library Reference                                 336

             return code is assigned to a signed integer, values in the
             range -2147483648 to 2147483647 are converted.



             strtrim




 Prototype   string strtrim(string: src, string: chrs);

 Arguments   src   The string to be trimmed.

             chrs  A string containing a list of characters to be trimmed
             from the beginning and end of src.

 Return Val. The trimmed string.

 Description The strtrim function adjusts a string to remove leading and
             trailing characters specified in the chrs string. The re-
             turned string contains a copy of the original string with the
             leading and trailing characters stripped.

 Example     This code demonstrates the usage of the strtrim function:

                string: trimmed;

                trimmed := strtrim("What to do now?", "Wh?");
                // trimmed contains "at to do now"


             strupper




 Prototype   string strupper(string: src);

 Arguments   src   The string to be converted.

 Return Val. An uppercase version of the src string.

 Description This function converts a string to uppercase.



             substr




 Prototype   string substr(string: s, int: pos, int: length);



             15. MEX Library Reference                                 337

 Arguments   s     The  source string from which the substring is to be
             extracted.

             pos   The starting position within s from which the substring
             is to be taken. A value of 1 specifies the first character in
             s.

             lengthThe maximum length of the substring to be extracted
             from s. The substr function will normally extract exactly
             length characters, but if this character count would exceed
             the length of the string, fewer characters will be extracted.

 Return Val. The substring extracted from s.

 Description The substr function extracts a substring from the source
             string s. The substring is defined by specifying a starting
             position within the string, and also by specifying the number
             of following characters which are to be taken as part of that
             substring.

 Example     This code shows how the substr function operates:

                #include <max.mh>

                int main()
                {
                  string: str;

                  str := substr("The quick brown fox", 11, 5);

                  print(str); // str now contains "brown"
                  return 0;
                }



             tag_dequeue_file




 Prototype   int tag_dequeue_file(int: posn);

 Arguments   posn  Position of the file within the tag list. The first
             file in the list is position 0.

 Return Val. TRUE if the file was successfully dequeued; FALSE otherwise.

 Description The tag_dequeue_file function is used to remove files from
             the internal queue of files to be downloaded.



             15. MEX Library Reference                                 338

             The number of files in the queue can be obtained using the
             tag_queue_size function, and information about specific queue
             entries can be obtained using the tag_get_name function.



             tag_get_name




 Prototype   int tag_get_name(int: posn, ref int: flags, ref string: file-
             name);

 Arguments   posn  Position of the file within the tag list. The first
             file in the list is position 0.

             flags Upon return, this variable is updated with a copy of
             the flags indicating the attributes for the file. These at-
             tributes are described in more detail in the tag_queue_file
             function.

             filename  A reference to a string. Upon return, this string
             is updated with the full filename and path of the file in the
             specified queue position.

 Return Val. TRUE if the file information was successfully queried; FALSE
             otherwise.

 Description The tag_get_name function is used to determine the names and
             attributes of files in the download queue.



             tag_queue_file




 Prototype   int tag_queue_file(string: filename, int: flags);

 Arguments   filename  The full path and filename of the file to be added
             to the queue.

                   WARNING!

                   All backslashes must be escaped in MEX programs. For
                   example, to specify a file called \max\misc\foo.bbs,
                   the parameter must contain "\\max\\misc\\foo.bbs".

             flags A list of zero or more FFLAG_* file attributes to be
             assigned to this file. Multiple attributes can be combined
             using the bitwise or operator.



             15. MEX Library Reference                                 339

 Return Val. TRUE if the file was successfully queued; FALSE otherwise.

 Description The tag_queue_file inserts a specific file into the user's
             download queue. The full path and filename of the file must
             be given. In addition, a number of optional flags from Table
             15.44 can be set to describe the file being downloaded:

             Table 15.44 File Queue Flags

              Flag             Description

              FFLAG_NOTIME     The file is not counted against the user's
                               time limit.
              FFLAG_NOBYTES    The file is not counted against the user's
                               file download limit.
              FFLAG_STAGE      The file is to be copied to the staging
                               path before being sent to the user, as is
                               typically done for CD-ROM drives.
              FFLAG_SLOW       The file is on slow media, so Maximus will
                               try not to access the drive any more than
                               necessary.



             tag_queue_size




 Prototype   int tag_queue_size();

 Arguments   None

 Return Val. The number of files in the download queue.

 Description This function returns the number of files that are currently
             in the download queue. The other tag_* functions use zero-
             based position numbers, so a queue containing 5 files will
             have file entries at positions 0, 1, 2, 3 and 4.



             tell




 Prototype   long tell(int: fd);

 Arguments   fd    A file descriptor, as returned by the open function.

 Return Val. The position within the file where the next read, readln,
             write, or writeln will take place.



             15. MEX Library Reference                                 340

 Description The tell function is used to determine the current offset of
             a file.



             term_length




 Prototype   int term_length();

 Arguments   None

 Return Val. The length of the user's terminal (in rows).

 Description The term_length function returns the current length of the
             user's terminal. If a set_textsize call has been made, the
             length parameter passed to that function is returned here.
             Otherwise, the value from the user record is returned.



             term_width




 Prototype   int term_width();

 Arguments   None

 Return Val. The width of the user's terminal (in columns).

 Description The term_width function returns the current width of the
             user's terminal. If a set_textsize call has been made, the
             width parameter passed to that function is returned here.
             Otherwise, the value from the user record is returned.



             time




 Prototype   long time();

 Arguments   None

 Return Val. The number of seconds elapsed since January 1st 1970 (UTC).

 Description This function returns the current value of the system timer.



             15. MEX Library Reference                                 341


             time_check




 Prototype   int time_check(int: state);

 Arguments   state The new state for time checking. If TRUE, time checking
             is enabled. Otherwise, time checking is disabled.

 Return Val. The original time checking state. This returns TRUE if the
             time checking was enabled prior to this function call; FALSE
             otherwise. This value can be used to restore the original
             time checking state at a later time.

 Description The time_check function is used to enable or disable time
             checking. Disabling time checking effectively "freezes" the
             user timer countdown, which would be desirable when writing a
             MEX-based chat program or call-back verifier.



             timeadjust




 Prototype   long timeadjust(long: delta);

 Arguments   delta The number of seconds to be added to the user's current
             time limit. A negative value for delta indicates that the
             user's time limit is to be decreased by the indicated amount.

 Return Val. The user's new time limit, measured in seconds.

 Description The timeadjust function is used to adjust the user's current
             time limit. Note that this function disregards the event file
             and the -t command line parameter. If this function is used
             blindly, the user could easily be allowed to overrun a sched-
             uled event.

             To get the user's current time limit measured in seconds,
             call timeadjust(0).



             timeadjustsoft




 Prototype   long timeadjustsoft(long: delta);



             15. MEX Library Reference                                 342

 Arguments   delta The number of seconds to be added to the user's current
             time limit. A negative value for delta indicates that the
             user's time limit is to be decreased by the indicated amount.

 Return Val. The user's new time limit, measured in seconds.

 Description The timeadjustsoft function is used to adjust the user's cur-
             rent time limit. This function will not allow the user's time
             limit to be adjusted to exceed an external event.



             timeleft




 Prototype   long timeleft();

 Arguments   None

 Return Val. The user's remaining time limit, in minutes.

 Description The timeleft function returns a value indicating the length
             of time that the current user is allowed to stay on-line, in
             minutes.



             timeon




 Prototype   long timeon();

 Arguments   None

 Return Val. The number of minutes that the user has been logged on.

 Description The timeon function returns the amount of time elapsed for
             the current call, in minutes.



             timestamp




 Prototype   void timestamp(ref struct _stamp: stamp);



             15. MEX Library Reference                                 343

 Arguments   stamp A reference to a _stamp structure. Upon return, this
             structure will be updated with a copy of the current date and
             time.

 Return Val. None

 Description This function retrieves the current date and time.



             uitostr




 Prototype   string uitostr(unsigned int: i);

 Arguments   i     The unsigned integer to be converted.

 Return Val. This function returns the string representation of the un-
             signed integer.

 Description The itostr function is used to convert an unsigned integer to
             a string. The converted string contains the ASCII representa-
             tion of the integer, from 0 to 65535. See the itostr function
             for converting signed integers.

             This function is useful when strings must be mixed with the
             results of integral computations.



             ultostr




 Prototype   string ultostr(unsigned long: l);

 Arguments   l     The unsigned long integer to be converted.

 Return Val. This function returns the string representation of the long
             integer.

 Description The ultostr function is used to convert an unsigned long in-
             teger to a string. The converted string contains the ASCII
             representation of the unsigned long integer, from 0 to
             4294967295. See the ltostr function for converting signed
             longs.

             This function is useful when strings must be mixed with the
             results of integral computations.



             15. MEX Library Reference                                 344

 Example     See the description for the itostr function for a related ex-
             ample.



             usercreate




 Prototype   int usercreate(ref struct _usr: u);

 Arguments   u     A reference to a user structure containing the user to
             be added.

 Return Val. TRUE if the user was successfully added; FALSE otherwise.
             (This function may fail if you try to add a user with a name
             or alias that already exists.)

 Description The usercreate function adds a user to the user file. The u
             structure should be completely filled out before the usercre-
             ate function is called.

             This function automatically assigns a new lastread pointer to
             the user before writing it to the user file. (The contents of
             u.lastread_ptr are ignored.)



             userfilesize




 Prototype   long userfilesize();

 Arguments   None

 Return Val. The size of the user file, measured in user records.

 Description The userfilesize returns the number of records (both deleted
             and non-deleted) that are present in the user file.



             userfindclose




 Prototype   void userfindclose();

 Arguments   None



             15. MEX Library Reference                                 345

 Return Val. None

 Description The userfindclose function releases the resource associated
             with the most recent call to userfindopen.



             userfindnext




 Prototype   int userfindnext(ref struct _usr: u);

 Arguments   u     A reference to a user structure. This should be a
             structure returned by a previous call to userfindopen, user-
             findnext or userfindprev. Upon exit, it is updated with a
             copy of the new user record.

 Return Val. TRUE if the following user record was found; FALSE otherwise.

 Description The userfindnext function finds the next record in the user
             file and returns it in the u structure.



             userfindopen




 Prototype   int userfindopen(string: name, string: alias, ref struct
             _usr: u);

 Arguments   name  The name of a user to search for within the user file.
             If name is the null string (""), the name field in the user
             record is not compared.

             alias The alias of a user to search for within the user file.
             If alias is the null string (""), the alias field in the user
             record is not compared.

             u     A reference to a user structure. Upon return, this will
             be updated with information about the found user record.

 Return Val. TRUE if the user record was found; FALSE otherwise.

 Description The userfindopen function is used to initiate a search of the
             user file. Specifying a name for either name and/or alias in-
             structs Maximus to look for that specific name or alias
             within the user file.



             15. MEX Library Reference                                 346

             If both name and alias are the null string (""), Maximus will
             return the first user in the user file.

             After finding the first record, the userfindnext and user-
             findprev functions can be used to find the preceding and fol-
             lowing user records, thereby allowing the entire user file to
             be searched.



             userfindprev




 Prototype   int userfindprev(ref struct _usr: u);

 Arguments   u     A reference to a user structure. This should be a
             structure returned by a previous call to userfindopen, user-
             findnext or userfindprev. Upon exit, it is updated with a
             copy of the new user record.

 Return Val. TRUE if the preceding user record was found; FALSE otherwise.

 Description The userfindprev function finds the previous record in the
             user file and returns it in the u structure.



             userfindseek




 Prototype   int userfindseek(long: rec, ref struct _usr: u);

 Arguments   rec   The record number to be read from the user file

             u     A reference to a user record. Upon return, this struc-
             ture is updated with a copy of the found user record.

 Return Val. TRUE if the user record was successfully retrieved; FALSE
             otherwise.

 Description The userfindseek function seeks directly to the specified
             user record. userfindopen need not be called prior to using
             userfindseek.

             To find the following or preceding user records to the record
             returned by this function, the userfindopen function must be
             used (with the u.name and u.alias fields set appropriately)
             to find this record, and then userfindnext or userfindprev
             can be used to locate subsequent records.



             15. MEX Library Reference                                 347


             userremove




 Prototype   int userremove(ref struct _usr: u);

 Arguments   u     A reference to a user record. This user record is to be
             removed from the user file.

 Return Val. TRUE if the record was successfully removed; FALSE otherwise.

 Description This function deletes the user contained in the user record
             specified by u.



             userupdate




 Prototype   int userupdate(ref struct _usr: u, string: origname, string:
             origalias);

 Arguments   u     A reference to a user record. The user specified by the
             origname and origalias fields will have its user record over-
             written by the record specified by u.

             origname  The original name of the record to be updated.

             origalias The original alias of the record to be updated.

 Return Val. TRUE if the record was successfully updated; FALSE otherwise.

 Description The userupdate function is used to update an existing record
             within the user file. The origname and origalias strings are
             used as keys for locating the original user record. If the
             user's name or alias has been changed in the update, the
             origname and origalias fields must reflect the user's origi-
             nal name and alias, as it was originally read from the user
             file.



             vidsync




 Prototype   void vidsync();



             15. MEX Library Reference                                 348

 Arguments   None

 Return Val. None

 Description The vidsync function synchronizes screen output with the lo-
             cal video buffer.

             vidsync is only needed when the id.instant_video variable is
             set to 0. If id.instant_video is set to 1, Maximus will han-
             dle synchronization automatically.

             The automatic video synchronization can be disabled since up-
             dating the screen can be a slow process. It is often more ef-
             ficient to disable screen updates, perform a number of func-
             tions which modify the screen buffer, and to then call vid-
             sync when all of the screen updates are complete.

             Note that many of the internal MEX functions that require in-
             put (such as input_str and related functions) will automati-
             cally update the screen regardless of the id.instant_video
             setting.



             write




 Prototype   int write(int: fd, ref string: s, int: len);

 Arguments   fd    A file descriptor, as returned by the open function.

             s     A reference to a string. This string should contain the
             bytes to be written to the file.

             len   The number of bytes to be written to the file.

 Return Val. If the return value is the same as len, the write was com-
             pletely successful.

             If the return value is less than len, only a portion of the
             requested number of bytes could be written. The disk is
             probably full, or some other form of disk error occurred.

 Description The write function writes a block of bytes to the specified
             file handle. This function writes blocks of bytes at a time
             with no consideration for "lines" in the destination file. To
             write a file a line at a time, see the writeln function.



             15. MEX Library Reference                                 349


             writeln




 Prototype   int writeln(int: fd, string: s);

 Arguments   fd    A file descriptor, as returned by the open function.

             s     The string to be written to the file.

 Return Val. If the return value is equal to strlen(s), the entire line
             was written to the file.

             If the return value is less than strlen(s), only part of the
             string could be written. The disk is probably full, or else
             some other disk error occurred.

 Description The writeln function writes an entire line to the specified
             file handle. Maximus will automatically append a newline to
             the end of the line.



             xfertime




 Prototype   long xfertime(int: protocol, long: bytes);

 Arguments   protocol  An index specifying the protocol to use for the
             purposes of time calculation. This can be usr.def_proto or
             one of the PROTOCOL_* constants from max.mh.

             bytes The size of the file whose transfer time is to be esti-
             mated.

 Return Val. The estimated number of seconds that will be required to
             transfer the file.

 Description The xfertime function is used to estimate the period of time
             that will be required to download a file of a specific size.
             The protocol parameter is used to calculate variations in the
             transfer time based on the efficiency of the various proto-
             cols.








                                                 16. MEX Language Reference


             16.1. Operator Precedence

             The following operator precedence is used in MEX expressions.
             Table 16.1 lists the operators in order from low to high
             precedence:

             Table 16.1 MEX Operator Precedence

              Operator       Associativity

              :=             right to left
              and  or        left to right
              =  <>          left to right
              <=  <  >=  >   left to right
              shl  shr       left to right
              &  |           left to right
              +  -           left to right
              *  /  %        left to right
              [ ] ( ) .      left to right




             16.2. Language Grammar

             This section contains an Extended Backus-Naur Form definition
             of the MEX grammar:

             program             <-   top_list

             top_list            <-     | top_list func_or_decl

             func_or_decl        <-   function | declaration

             function            <-   typedefn id ( arg_list )
                                      trailing_part

             trailing_part       <-   function_block | ;

             function_block      <-   { declarator_list statement_list }

             arg_list            <-     | ... | argument , arg_list
                                 <-   argument

             argument            <-   opt_ref typename id

             opt_ref             <-     | ref



             16. MEX Language Reference                                352


             block               <-   { declarator_list statement_list }

             declarator_list     <-     | declarator_list declaration

             declaration         <-   typename id_list ;
                                 <-   struct id { declarator_list } ;

             typename            <-   typedefn :

             typedefn            <-   char | int | long | signed char
                                 <-   signed int
                                 <-   signed long | unsigned char
                                 <-   unsigned int
                                 <-   unsigned long | void | string
                                 <-   array [ range ] of typedefn
                                 <-   struct id

             range               <-   <constant_int> .. <constant_int>
                                 <-   <constant_int> ..

             id_list             <-   id_list , id | id

             statement_list      <-     | statement_list statement

             opt_statement       <-     | statement

             statement           <-   ; | block | expr ;
                                 <-   if paren_expr statement else_part
                                 <-   goto id ;
                                 <-   id : statement
                                 <-   while paren_expr statement |
                                 <-   do statement while paren_expr ;
                                 <-   for ( expr ; opt_expr ; opt_expr )
             statement
                                 <-   return opt_expr ;

             else_part           <-     | else statement

             function_call       <-   id ( expr_list )

             expr_list           <-     | expr | expr , expr_list

             primary             <-   paren_expr | ( typedefn ) primary |
                                 <-   sizeof ( typedefn ) | function_call
                                 <-   literal | ident

             opt_expr            <-     | expr

             paren_expr          <-   ( expr )

             expr                <-   expr * expr | expr / expr
                                 <-   expr % expr



             16. MEX Language Reference                                353

                                 <-   expr + expr | expr - expr
                                 <-   expr <= expr
                                 <-   expr < expr | expr shr expr
                                 <-   expr shl expr
                                 <-   expr & expr | expr | expr
                                 <-   expr and expr
                                 <-   expr or expr | expr = expr
                                 <-   expr <> expr
                                 <-   expr >= expr | expr > expr
                                 <-   - primary
                                 <-   primary | ident := expr

             literal             <-   <constant_char> | <constant_int>
                                 <-   <constant_long> | const_string

             const_string        <-   <constant_string> | const_string
                                 <-   <constant_string>

             ident               <-   <identifier> | ident [ expr ]
                                 <-   ident . id

             id                  <-   <identifier>